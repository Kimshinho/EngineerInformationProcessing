5
정보처리기사 필기   핵심 요 약•  나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 
거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 
것으로, 점진적 모형이라고도 한다. 
•  소프트웨어를 개발하면서 발생할 수 있는 위험을 관리
하고 최소화하는 것을 목적으로 한다.
•  점진적으로 개발 과정이 반복되므로 누락되거나 추가
된 요구사항을 첨가할 수 있고, 정밀하며, 유지보수 과
정이 필요 없다.
계획 수립
고객 평 가위험 분석
개발 및 검증계획 수립 위험 분 석개발 및 검증 고객 평 가 → → →
애자일은 ‘민첩한’, ‘기민한’이라는 의미로, 고객의 요구사
항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복
하면서 개발과정을 진행한다.
•  애자일 모형은 어느 특정 개발 방법론이 아니라 좋은 
것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 
초점을 맞춘 방법론을 통칭한다.
• 애자일 모형은 기업 활동 전반에 걸쳐 사용된다.
•  애자일 모형을 기반으로 하는 소프트웨어 개발 모형에
는 스크럼(Scrum), XP(eXtreme Programming), 칸반
(Kanban), Lean, 크리스탈(Crystal), ASD(Adaptive 
Software Development), 기능 중심 개발(FDD; 
Feature Driven Development), DSDM(Dynamic 
System Development Method), DAD(Disciplined 
Agile Delivery) 등이 있다.스크럼이란 럭비에서 반칙으로 경기가 중단된 경우 양 팀
의 선수들이 럭비공을 가운데 두고 상대팀을 밀치기 위해 
서로 대치해 있는 대형을 말한다. 스크럼은 이처럼 팀이 
중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용
어이다.
•  스크럼은 팀원 스스로가 스크럼 팀을 구성(self-
organizing)해야 하며, 개발 작업에 관한 모든 것을 스
스로 해결(cross-functional)할 수 있어야 한다.
•  스크럼 팀은 제품 책임자, 스크럼 마스터, 개발팀으로 
구성된다. 
제품 책임자(PO; Product Owner)
•  이해관계자들 중 개발될 제품에 대한 이해도가 높고, 
요구사항을 책임지고 의사 결정할 사람으로 선정하는
데, 주로 개발 의뢰자나 사용자가 담당한다.
•  이해관계자들의 의견을 종합하여 제품에 대한 요구사
항을 작성하는 주체다.
•  제품에 대한 테스트를 수행하면서 주기적으로 요구사
항의 우선순위를 갱신한다. 
스크럼 마스터(SM; Scrum Master)
•  스크럼 팀이 스크럼을 잘 수행할 수 있도록 객관적인 
시각에서 조언을 해주는 가이드 역할을 수행한다. 팀원
들을 통제하는 것이 목표가 아니다.
•  일일 스크럼 회의를 주관하여 진행 사항을 점검하고, 개
발 과정에서 발생된 장애 요소를 공론화하여 처리한다.25.8, 21.5, 20.91.  프로세스와 도구보다는 개인과 상호작용에 더 가치를 
둔다.
## 2. 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
## 3. 계약 협상보다는 고객과 협업에 더 가치를 둔다.
## 4.  계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 
둔다.25.8, 24.7, 23.7, 22.3, 21.8, 21.4, 21.3, 20.8
## 23.2, 22.3
애자일 모형(Agile Model)
2400105
006핵심애자일 개발 4가지 핵심 가치
2400132
007핵심
스크럼의 개요
2400201
008핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   5PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   5 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

6
정보처리기사 필기   핵심 요 약
제품 백로그
(Product Backlog)제품 개발에 필요한 모든 요구사항(User 
Story)을 우선순위에 따라 나열한 목록
스프린트 계획 회의
(Sprint Planning 
Meeting)제품 백로그 중 이번 스프린트에서 수행할 작
업을 대상으로 단기 일정을 수립하는 것
스프린트(Sprint)• 실제 개발 작업을 진행하는 과정으로, 보통  
2 ~ 4주 정도의 기간 내에서 진행함
• 스프린트 백로그에 작성된 태스크를 대상
으로 속도(Velocity)를 추정한 후 개발 담당
자에게 할당함
일일 스크럼 회의
(Daily Scrum 
Meeting)• 모든 팀원이 매일 약속된 시간에 약 15분 
정도의 짧은 시간동안 진행 상황을 점검  
함
• 회의는 보통 서서 진행하며, 남은 작업 시간
은 소멸 차트(Burn-down Chart)에 표시함
스프린트 검토 회의
(Sprint Review)부분 또는 전체 완성 제품이 요구사항에 잘 
부합되는지 사용자가 포함된 참석자 앞에서 
테스팅을 수행함
스프린트 회고
(Sprint 
Retrospective)스프린트 주기를 되돌아보며 정해놓은 규칙
을 잘 준수했는지, 개선할 점은 없는지 등을 
확인하고 기록함24.7, 24.5, 23.2, 22.3
XP(eXtreme Programming)는 수시로 발생하는 고객의 
요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 
과정의 반복을 극대화하여 개발 생산성을 향상시키는 방
법이다.
•  XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 
적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 
것을 목적으로 한다. 
•  릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반
영에 대한 가시성을 높인다. 단계 현행 시스템 내용
1단계시스템 구성 파악조직의 주요 업무를 담당하는 기간 
업무와 이를 지원하는 지원 업무로 
구분하여 기술함
시스템 기능 파악현재 제공하는 기능들을 주요 기능
과 하부 기능, 세부 기능으로 구분하
여 계층형으로 표시함
시스템 인터페이스 
파악단위 업무 시스템 간에 주고받는 데
이터의 종류, 형식, 프로토콜, 연계 
유형, 주기 등을 명시함Pair Programming
(짝 프로그래밍)다른 사람과 함께 프로그래밍을 수행함으
로써 개발에 대한 책임을 공동으로 나눠 
갖는 환경을 조성 함
Collective Ownership
(공동 코드 소유)개발 코드에 대한 권한과 책임을 공동으
로 소유 함
Test-Driven 
Development
(테스트 주도 개발)• 개발자가 실제 코드를 작성하기 전에 테
스트 케이스를 먼저 작성하므로 자신이 
무엇을 해야할지를 정확히 파악 함
• 테스트가 지속적으로 진행될 수 있도록 
자동화된 테스팅 도구(구조, 프레임워
크)를 사용 함
Whole Team
(전체 팀)개발에 참여하는 모든 구성원(고객 포함)
들은 각자 자신의 역할이 있고 그 역할에 
대한 책임을 가져야 함
Continuous 
Integration
(계속적인 통합)모듈 단위로 나눠서 개발된 코드들은 하
나의 작업이 마무리될 때마다 지속적으로 
통합됨
Design Improvement
(디자인 개선) 또는 
Refactoring(리팩토링)프로그램 기능의 변경 없이, 단순화, 유연
성 강화 등을 통해 시스템을 재구성 함
Small Releases
(소규모 릴리즈)릴리즈 기간을 짧게 반복함으로써 고객의 
요구 변화에 신속히 대응할 수 있음24.7, 24.5, 23.5, 22.4, 20.9
## 25.8, 25.2, 24.5, 24.2, 23.7, 23.5, 22.7, 22.4, 21.8, 20.9, 20.621.3개발팀(DT; Development Team)
•  제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로, 
개발자 외에도 디자이너, 테스터 등 제품 개발을 위해 
참여하는 모든 사람이 대상이 된다.
• 보통 최대 인원은 7~8명이 적당하다.• 애자일 개발 방법론을 기반으로 한다.
•  XP의 5가지 핵심 가치  : 의사소통(Communication), 단
순성(Simplicity), 용기(Courage), 존중(Respect), 피드
백(Feedback) 
XP의 주요 실천 방법  
(Practice)
2400331
011핵심
스크럼 개발 프로세스
2400202
009핵심
XP(eXtreme Programming)
2400301
010핵심현행 시스템 파악
2400401
012핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   6PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   6 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

10
정보처리기사 필기   핵심 요 약
HIPO(Hierarchy Input Process Output)는 시스템의 분
석 및 설계나 문서화할 때 사용되는 기법으로, 시스템 실
행 과정인 입력, 처리, 출력의 기능을 나타낸다.
•  기본 시스템 모델은 입력, 처리, 출력으로 구성되며, 하
향식 소프트웨어 개발을 위한 문서화 도구이다.
• 체계적인 문서 관리가 가능하다.
• 기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉽다.
• 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
• 변경, 유지보수가 용이하다.
•  시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이
들 간의 인터페이스를 계층 구조로 표현한 것을 HIPO 
Chart라고 한다.
HIPO Chart의 종류
•  가시적 도표(도식 목차)  : 시스템의 전체적인 기능과 흐름
을 보여주는 계층(Tree) 구조도
•  총체적 도표(총괄도표, 개요 도표)  : 프로그램을 구성하는 
기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적
인 정보를 제공하는 도표
•  세부적 도표(상세 도표)  : 총체적 도표에 표시된 기능을 
구성하는 기본 요소들을 상세히 기술하는 도표UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에
서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통
이 원활하게 이루어지도록 표준화한 대표적인 객체지향 
모델링 언어이다. 
•  UML은 Rumbaugh(OMT), Booch, Jacobson 등의 객
체지향 방법론의 장점을 통합하였으며, 객체 기술에 
관한 국제표준화기구인 OMG(Object Management 
Group)에서 표준으로 지정하였다. 
•  UML을 이용하여 시스템의 구조를 표현하는 6개의 구
조 다이어그램과 시스템의 동작을 표현하는 7개의 행위 
다이어그램을 작성할 수 있다.
•  각각의 다이어그램은 사물과 사물 간의 관계를 용도에 
맞게 표현한다.
•  UML의 구성 요소에는 사물(Things), 관계(Relation-
ships), 다이어그램(Diagram) 등이 있다.
관계는 사물과 사물 사이의 연관성을 표현하는 것으로, 
연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관
계, 실체화 관계 등이 있다.
연관(Association) 관계
연관 관계는 2개 이상의 사물이 서로 관련되어 있음을 표
현한다.
집합(Aggregation) 관계
집합 관계는 하나의 사물이 다른 사물에 포함되어 있는 관
계를 표현한다.
포함(Composition) 관계
포함 관계는 집합 관계의 특수한 형태로, 포함하는 사물
의 변화가 포함되는 사물에게 영향을 미치는 관계를 표현
한다.
일반화(Generalization) 관계
일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적
인지 구체적인지를 표현한다. • PSL/PSA  
 -  미시간 대학에서 개발한 것으로 PSL과 PSA를 사용
하는 자동화 도구이다.
•  TAGS(Technology for Automated Generation of Systems)  
 -   시스템 공학 방법 응용에 대한 자동 접근 방법으로, 
개발 주기의 전 과정에 이용할 수 있는 통합 자동화 
도구이다.25.5, 24.7, 22.3, 20.9
## 25.2, 24.2, 23.7, 22.7, 20.6
## 24.2, 23.5, 22.7, 21.8, 21.5, 20.8UML(Unified Modeling 
Language)의 개요
2400901
023핵심
HIPO
2400802
022핵심
관계(Relationships)
2400903
024핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   10PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   10 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

11
정보처리기사 필기   핵심 요 약의존(Dependency) 관계
의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 
있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안
만 연관을 유지하는 관계를 표현한다.
•  일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 
매개 변수로 사용하는 경우에 나타나는 관계이다.
실체화(Realization) 관계
 실체화 관계는 사물이 할 수 있거나 해야 하는 기능(행위, 인
터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현한다.
다이어그램은 사물과 관계를 도형으로 표현한 것이다. 
•  여러 관점에서 시스템을 가시화한 뷰(View)를 제공함
으로써 의사소통에 도움을 준다.
•  정적 모델링에서는 주로 구조적 다이어그램을 사용하
고 동적 모델링에서는 주로 행위 다이어그램을 사용  
한다.
• 구조적(Structural) 다이어그램의 종류  
클래스 다이어그램
(Class Diagram)• 클래스와 클래스가 가지는 속성, 클래스 
사이의 관계를 표현함
• 시스템의 구조를 파악하고 구조상의 문제
점을 도출할 수 있음
객체 다이어그램
(Object Diagram)• 클래스에 속한 사물(객체)들, 즉 인스턴스
(Instance)를 특정 시점의 객체와 객체 사
이의 관계로 표현함
• 럼바우(Rumbaugh) 객체지향 분석 기법
에서 객체 모델링에 활용됨
컴포넌트 다이어그램
(Component 
Diagram)• 실제 구현 모듈인 컴포넌트 간의 관계나 
컴포넌트 간의 인터페이스를 표현함
•구현 단계에서 사용되는 다이어그램
배치 다이어그램
(Deployment 
Diagram)• 결과물, 프로세스, 컴포넌트 등 물리적 요
소들의 위치를 표현함
•노드와 의사소통(통신) 경로로 표현함
•구현 단계에서 사용되는 다이어그램
복합체 구조 다이어
그램
(Composite 
Structure Diagram)클래스나 컴포넌트가 복합 구조를 갖는 경
우 그 내부 구조를 표현함
패키지 다이어그램
(Package Diagram)유스케이스나 클래스 등의 모델 요소들을 
그룹화한 패키지들의 관계를 표현함• 행위(Behavioral) 다이어그램의 종류
유스케이스 
다이어그램
(Use Case 
Diagram)• 사용자의 요구를 분석하는 것으로 기능 모
델링 작업에 사용함
• 사용자(Actor)와 사용 사례(Use Case)로 구
성되며, 사용 사례 간에는 여러 형태의 관
계로 이루어짐
순차 다이어그램
(Sequence 
Diagram)상호 작용하는 시스템이나 객체들이 주고받
는 메시지를 표현함
커뮤니케이션 
다이어그램
(Communication 
Diagram)순차 다이어그램과 같이 동작에 참여하는 객
체들이 주고받는 메시지를 표현하는데, 메시
지뿐만 아니라 객체들 간의 연관까지 표현함
상태 다이어그램
(State Diagram)• 하나의 객체가 자신이 속한 클래스의 상태 
변화 혹은 다른 객체와의 상호 작용에 따
라 상태가 어떻게 변화하는지를 표현함
• 럼바우(Rumbaugh) 객체지향 분석 기법에
서 동적 모델링에 활용됨
활동 다이어그램
(Activity Diagram)시스템이 어떤 기능을 수행하는지 객체의 처
리 로직이나 조건에 따른 처리의 흐름을 순
서에 따라 표현함
상호작용 개요 
다이어그램
(Interaction 
Overview Diagram)상호작용 다이어그램 간의 제어 흐름을 표현
함
타이밍 다이어그램
(Timing Diagram)객체 상태 변화와 시간 제약을 명시적으로 
표현함
스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가
적인 기능을 표현하기 위해 사용한다.
•  길러멧(Guilemet)이라고 부르는 겹화살괄호(<< >>) 사
이에 표현할 형태를 기술한다.
• 주로 표현되는 형태는 다음과 같다.
<<include>>연결된 다른 UML 요소에 대해 포함 관계에 있는 
경우
<<extend>>연결된 다른 UML 요소에 대해 확장 관계에 있는 
경우
<<interface>> 인터페이스를 정의하는 경우
<<exception>> 예외를 정의하는 경우
<<constructor>> 생성자 역할을 수행하는 경우25.8, 25.5, 25.2, 23.7, 23.5, 23.2, 22.3, 21.8, 21.5, 21.3, 20.9, 20.8, 20.6
## 24.7, 23.7, 22.7, 20.6다이어그램(Diagram)
2400904
025핵심
스테레오 타입(Stereotype)
2400931
026핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   11PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   11 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

12
정보처리기사 필기   핵심 요 약
유스케이스 다이어그램은 개발될 시스템과 관련된 외부 
요소들, 즉 사용자와 다른 외부 시스템들이 개발될 시스
템을 이용해 수행할 수 있는 기능을 사용자의 관점(View)
에서 표현한 것이다.
유스케이스 다이어그램의 구성 요소
유스케이스 다이어그램은 시스템, 액터, 유스케이스, 관
계로 구성된다.
시스템(System) / 
시스템 범위
(System Scope)시스템 내부에서 수행되는 기능들을 외부 시스
템과 구분하기 위해 시스템 내부의 유스케이스
들을 사각형으로 묶어 시스템의 범위를 표현함
액터(Actor)• 시스템과 상호작용을 하는 모든 외부 요소로, 
사람이나 외부 시스템을 의미함
• 주액터 : 시스템을 사용함으로써 이득을 얻는 
대상으로, 주로 사람이 해당함
• 부액터 : 주액터의 목적 달성을 위해 시스템
에 서비스를 제공하는 외부 시스템으로, 조직
이나 기관 등이 될 수 있음
유스케이스
(Use Case)사용자가 보는 관점에서 시스템이 액터에게 제
공하는 서비스 또는 기능을 표현한 것
관계
(Relationship) 유스케이스 다이이그램에서 관계는 액터와 유
스케이스, 유스케이스와 유스케이스 사이에서 
나타날 수 있으며, 연관 관계, 포함 관계, 확장 
관계, 일반화 관계를 표현할 수 있음
※  유스케이스 확장 관계  : 유스케이스가 특정 조건에 부합
되어 유스케이스의 기능이 확장될 때 원래의 유스케이
스와 확장된 유스케이스와의 관계임
클래스 다이어그램은 시스템을 구성하는 클래스, 클래스
의 특성인 속성과 오퍼레이션, 속성과 오퍼레이션에 대한 
제약조건, 클래스 사이의 관계를 표현한 것이다.
클래스 다이어그램의 구성 요소
클래스 다이어그램은 클래스, 제약조건, 관계 등으로 구
성된다.클래스(Class)• 클래스는 각각의 객체들이 갖는 속성과 오퍼레
이션(동작)을 표현함
• 일반적으로 3개의 구획(Compartment)으로 나눠 
클래스의 이름, 속성, 오퍼레이션을 표기함
• 속성(Attribute) : 클래스의 상태나 정보를 표현함
• 오퍼레이션(Operation) : 클래스가 수행할 수 있
는 동작으로, 함수(메소드, Method)라고도 함
제약조건속성에 입력될 값에 대한 제약조건이나 오퍼레이션 
수행 전후에 지정해야 할 조건이 있다면 이를 적음
관계
(Relationships)• 관계는 클래스와 클래스 사이의 연관성을 표현
함
• 클래스 다이어그램에 표현하는 관계에는 연관 
관계, 집합 관계, 포함 관계, 일반화 관계, 의존 
관계가 있음
•  사용자의 만족도에 가장 큰 영향을 미치는 중요한 요소
로, 소프트웨어 영역 중 변경이 가장 많이 발생한다.
•  사용자의 편리성과 가독성을 높임으로써 작업 시간을 
단축시키고 업무에 대한 이해도를 높여준다.25.2, 24.5, 23.7, 23.5, 22.4, 21.5, 21.3
## 21.8, 21.3순차 다이어그램은 시스템이나 객체들이 메시지를 주고받
으며 시간의 흐름에 따라 상호 작용하는 과정을 액터, 객
체, 메시지 등의 요소를 사용하여 그림으로 표현한 것이다.
순차 다이어그램의 구성 요소
순차 다이어그램은 액터, 객체, 생명선, 실행, 메시지 등
으로 구성된다.
액터
(Actor)시스템으로부터 서비스를 요청하는 외부 요소로, 사
람이나 외부 시스템을 의미함
객체
(Object)메시지를 주고받는 주체
생명선
(Lifeline)객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 
점선을 그어 표현함
실행 상자
(Active Box)객체가 메시지를 주고받으며 구동되고 있음을 표현함
메시지
(Message)객체가 상호 작용을 위해 주고받는 메시지24.5, 23.2, 22.7, 22.4, 21.8, 20.8
## 25.2, 21.5유스케이스(Use Case)  
다이어그램
2401001
027핵심
클래스(Class) 다이어그램
2401002
028핵심
사용자 인터페이스(UI)의 특징
2401102
030핵심순차(Sequence) 다이어그램
2401003
029핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   12PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   12 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

13
정보처리기사 필기   핵심 요 약• 최소한의 노력으로 원하는 결과를 얻을 수 있게 한다.
•  사용자 중심으로 설계되어 사용자 중심의 상호 작용이 
되도록 한다.
• 수행 결과의 오류를 줄인다. 
•  사용자의 막연한 작업 기능에 대해 구체적인 방법을 제
시해 준다.
• 정보 제공자와 공급자 간의 매개 역할을 수행한다.
•  사용자 인터페이스를 설계하기 위해서는 소프트웨어 
아키텍처를 반드시 숙지해야 한다.
UI 설계 도구 
UI 설계 도구는 사용자의 요구사항에 맞게 UI의 화면 구
조나 화면 배치 등을 설계할 때 사용하는 도구로, 종류에
는 와이어프레임, 목업, 스토리보드, 프로토타입, 유스케
이스 등이 있다.
와이어프레임(Wireframe)
•  와이어프레임은 기획 단계의 초기에 제작하는 것으로, 
페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대
한 뼈대를 설계하는 단계이다. 
•  개발자나 디자이너 등이 레이아웃을 협의하거나 현재 
진행 상태 등을 공유하기 위해 와이어프레임을 사용  
한다.
•  와이어프레임 툴  : 손그림, 파워포인트, 키노트, 스케치, 
일러스트, 포토샵 등 •  사용자 중심  : 사용자가 쉽게 이해하고 편리하게 사용할 
수 있는 환경을 제공하며, 실사용자에 대한 이해가 바
탕이 되어야 함
•  사용성 : 사용자가 소프트웨어를 얼마나 빠르고 쉽게 이
해할 수 있는지, 얼마나 편리하고 효율적으로 사용할 
수 있는지를 말하는 것으로, 사용자 인터페이스 설계 
시 가장 우선적으로 고려해야 함 
•  심미성 : 디자인적으로 완성도 높게 글꼴이나 색상을 적
용하고 그래픽 요소를 배치하여 가독성을 높일 수 있도
록 설계해야 함
•  오류 발생 해결  : 오류가 발생하면 사용자가 쉽게 인지할 
수 있도록 설계해야 함
•  직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
•  유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 
함
• 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 함
•  유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 
최소화해야 함•  CLI(Command Line Interface)  : 명령과 출력이 텍스트 형
태로 이뤄지는 인터페이스
•  GUI(Graphical User Interface)  : 아이콘이나 메뉴를 마우
스로 선택하여 작업을 수행하는 그래픽 환경의 인터페
이스
•  NUI(Natural User Interface)  : 사용자의 말이나 행동으로 
기기를 조작하는 인터페이스
•   VUI(Voice User Interface)  : 사람의 음성으로 기기를 조작
하는 인터페이스
•  OUI(Organic User Interface) : 모든 사물과 사용자 간의 상
호작용을 위한 인터페이스로, 소프트웨어가 아닌 하드
웨어 분야에서 사물 인터넷(Internet of Things), 가상
현실(Virtual Reality), 증강현실(Augmented Reality), 
혼합현실(Mixed Reality) 등과 함께 대두되고 있음25.8, 23.7, 23.5, 22.7, 22.4, 21.8
## 25.5, 23.7, 20.8, 20.624.5, 22.4, 21.8, 20.8, 20.6
## 25.2, 24.5, 23.5, 23.2, 22.3• 사용자의 입력을 검증할 수 있어야 한다.
•  에러 처리와 그와 관련된 에러 메시지를 표시할 수 있
어야 한다.
• 도움과 프롬프트(Prompt)를 제공해야 한다.20.9
사용자 인터페이스  
개발 시스템의 기능
2401106
034핵심사용자 인터페이스의  구분
2401103
031핵심
사용자 인터페이스의  기본 원칙
2401104
032핵심사용자 인터페이스의  설계 지침
2401105
033핵심
UI 설계 도구
2459906
035핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   13PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   13 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

15
정보처리기사 필기   핵심 요 약•  체크 박스(Check Box)  : 여러 개의 선택 상황에서 1개 이
상의 값을 선택할 수 있는 버튼임
•  라디오 버튼(Radio Button)  : 여러 항목 중 하나만 선택할 
수 있는 버튼임
•  텍스트 박스(Text Box)  : 사용자가 데이터를 입력하고 수
정할 수 있는 상자임
•  콤보 상자(Combo Box)  : 이미 지정된 목록 상자에 내용
을 표시하여 선택하거나 새로 입력할 수 있는 상자임
•  목록 상자(List Box)  : 콤보 상자와 같이 목록을 표시하지
만 새로운 내용을 입력할 수 없는 상자임단계적 분해
(Stepwise 
Refinement)단계적 분해는 Niklaus Wirth에 의해 제안된 하향
식 설계 전략으로, 문제를 상위의 중요 개념으로
부터 하위의 개념으로 구체화시키는 분할 기법
정보 은닉
(Information 
Hiding)정보 은닉은 한 모듈 내부에 포함된 절차와 자료
들의 정보가 감추어져 다른 모듈이 접근하거나 
변경하지 못하도록 하는 기법
모듈화
(Modularity)모듈화란 소프트웨어의 성능을 향상시키거나 시
스템의 수정 및 재사용, 유지 관리 등이 용이하도
록 시스템의 기능들을 모듈 단위로 나누는 것을 
의미함
추상화
(Abstraction)• 추상화는 문제의 전체적이고 포괄적인 개념을 
설계한 후 차례로 세분화하여 구체화시켜 나가
는 것
• 추상화의 유형  : 과정 추상화, 데이터 추상화, 
제어 추상화❶  설계 목표 설정  : 시스템의 개발 방향을 명확히 하기 위
해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 
요구사항을 분석하여 전체 시스템의 설계 목표를 설정
함
❷  시스템 타입 결정  : 시스템과 서브시스템의 타입을 결정
하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선
택함
❸  아키텍처 패턴 적용  : 아키텍처 패턴을 참조하여 시스템
의 표준 아키텍처를 설계함
❹  서브시스템 구체화  : 서브시스템의 기능 및 서브시스템 
간의 상호작용을 위한 동작과 인터페이스를 정의함
❺  검토 : 아키텍처가 설계 목표에 부합하는지, 요구사항
이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 
등을 검토함25.8, 25.2, 24.7, 24.5, 24.2, 23.7, 22.3, 21.821.3
소프트웨어 개발의 설계 단계는 크게 상위 설계와 하위 설
계로 구분할 수 있다.
 상위 설계 하위 설계
별칭 아키텍처 설계, 예비 설계 모듈 설계, 상세 설계
설계 
대상시스템의 전체적인 구조 시스템의 내부 구조 및 행위
세부 
목록구조, DB, 인터페이스 컴포넌트, 자료 구조, 알고리즘20.9소프트웨어 아키텍처의 품질 속성은 소프트웨어 아키텍처
가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장
할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소
들을 시스템 측면, 비즈니스 측면, 아키텍처 측면으로 구
분하여 구체화시켜 놓은 것이다. 
•  시스템 측면  : 성능, 보안, 가용성, 기능성, 사용성, 변경 
용이성, 확장성 등
•  비즈니스 측면  : 시장 적시성, 비용과 혜택, 예상 시스템 
수명 등
•  아키텍처 측면  : 개념적 무결성, 정확성, 완결성, 구축 
가능성 등21.5
## 23.5, 23.2, 22.3
소프트웨어 아키텍쳐 설계의  
기본 원리
2459908
039핵심소프트웨어 아키텍처의  
품질 속성
2402106
040핵심
소프트웨어 아키텍처의  
설계 과정
2402107
041핵심UI 요소
2401931
037핵심
상위 설계와 하위 설계
2402131
038핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   15PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   15 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

16
정보처리기사 필기   핵심 요 약
컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 
수 있도록 명세한 것으로, 소프트웨어 컴포넌트에 대한 
정확한 인터페이스를 명세한다.
•  협약에 의한 설계 시 명세에 포함될 조건에는 선행 조
건, 결과 조건, 불변 조건이 있다. 
선행 조건
(Precondition)오퍼레이션이 호출되기 전에 참이 되어야 할 조
건
결과 조건
(Postcondition)오퍼레이션이 수행된 후 만족되어야 할 조건
불변 조건
(Invariant)오퍼레이션이 실행되는 동안 항상 만족되어야 할 
조건•  컨트롤러(Controller)  : 사용자로부터 입력된 변경 요청을 
처리하기 위해 모델에게 명령을 보냄
Input
outputController
ViewModel갱신
제어
변경 알림
정보 요청
모델-뷰-컨트롤러 패턴은 서브시스템을 3개의 부분으로 
구조화하는 패턴이며, 각 부분의 역할은 다음과 같다.
•  모델(Model)  : 서브시스템의 핵심 기능과 데이터를 보관
함
• 뷰(View)  : 사용자에게 정보를 표시함 마스터-슬레이
브 패턴
(Master-Slave 
Pattern)• 마스터 컴포넌트에서 슬레이브 컴포넌트로 작
업을 분할한 후, 슬레이브 컴포넌트에서 처리
된 결과물을 다시 돌려받는 방식으로 작업을 
수행하는 패턴
• 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 
주로 활용됨
브로커 패턴
(Broker Pattern)• 사용자가 원하는 서비스와 특성을 브로커 컴
포넌트에 요청하면 브로커 컴포넌트가 요청에 
맞는 컴포넌트와 사용자를 연결해줌
•분산 환경 시스템에서 주로 활용됨
피어-투-피어 
패턴
(Peer-To-Peer 
Pattern)피어(Peer)를 하나의 컴포넌트로 간주하며, 각 피
어는 서비스를 호출하는 클라이언트가 될 수도, 
서비스를 제공하는 서버가 될 수도 있는 패턴
이벤트-버스 
패턴
(Event-Bus 
Pattern) 소스가 특정 채널에 이벤트 메시지를 발행
(Publish)하면, 해당 채널을 구독(Subscribe)한 리
스너들이 메시지를 받아 이벤트를 처리하는 방식
블랙보드 패턴
(Blackboard 
Pattern)• 모든 컴포넌트들이 공유 데이터 저장소와 블
랙보드 컴포넌트에 접근이 가능한 형태로, 컴
포넌트들은 검색을 통해 블랙보드에서 원하는 
데이터를 찾을 수 있음
• 음성 인식, 차량 식별, 신호 해석 등에 주로 활
용됨
인터프리터 패턴
(Interpreter 
Pattern) 프로그램 코드의 각 라인을 수행하는 방법을 지
정하고, 기호마다 클래스를 갖도록 구성됨 파이프-필터 패턴은 데이터 스트림 절차의 각 단계를 필
터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데
이터를 전송하는 패턴이다.
•  필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 
용이하다.
•  필터 컴포넌트들을 재배치하여 다양한 파이프라인을 
구축하는 것이 가능하다.
•  파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 
주로 사용된다.
• 대표적으로 UNIX의 쉘(Shell)이 있다.
InputSource InputSink Filter1 Filter2Pipe1 Pipe2 Pipe325.8, 24.7, 23.7, 22.7, 21.8, 21.5, 20.920.8
## 24.5, 23.5, 21.8
## 25.5, 24.7, 23.2, 22.4파이프 - 필터 패턴  
(Pipe - Filter Pattern)
2402204
043핵심
모델 - 뷰 - 컨트롤러 패턴
(Model - View - Controller Pattern)
2402205
044핵심협약(Contract)에 의한 설계
2459909
042핵심
기타 패턴
2402206
045핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   16PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   16 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

17
정보처리기사 필기   핵심 요 약객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡
슐화한) 하나의 소프트웨어 모듈이다.  
데이터• 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 
나타냄 
•속성(Attribute), 상태, 변수, 상수, 자료 구조라고도 함
함수• 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상
태)를 처리하는 알고리즘
• 객체의 상태를 참조하거나 변경하는 수단이 되는 것
으로 메소드(Method, 행위), 서비스(Service), 동작
(Operation), 연산이라고도 함
• 객체의 특성  
 - 객체는 독립적으로 식별 가능한 이름을 가지고 있다. 
 -  객체가 가질 수 있는 조건을 상태(State)라고 하는
데, 일반적으로 상태는 시간에 따라 변한다.
 - 객체와 객체는 상호 연관성에 의한 관계가 형성된다.
 -   객체가 반응할 수 있는 메시지(Message)의 집합을 행
위라고 하며, 객체는 행위의 특징을 나타낼 수 있다. 
 -   객체는 일정한 기억장소를 가지고 있다. 
•  객체의 메소드는 다른 객체로부터 메시지를 받았을 때 
정해진 기능을 수행한다.캡슐화는 데이터(속성)와 데이터를 처리하는 함수를 하나
로 묶는 것을 의미한다. 
•  캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은
폐(정보 은닉)되어 외부에서의 접근이 제한적이기 때문
에 외부 모듈의 변경으로 인한 파급 효과가 적다. 
• 캡슐화된 객체들은 재사용이 용이하다. 
•  객체들 간의 메시지를 주고받을 때 상대 객체의 세부 
내용은 알 필요가 없으므로 인터페이스가 단순해지고, 
객체 간의 결합도가 낮아진다.
클래스는 공통된 속성과 연산(행위)을 갖는 객체의 집합으
로, 객체의 일반적인 타입(Type)을 의미한다. 
•  클래스는 각각의 객체들이 갖는 속성과 연산을 정의하
고 있는 틀이다. 
•  클래스는 객체지향 프로그램에서 데이터를 추상화하는 
단위이다.
•  클래스에 속한 각각의 객체를 인스턴스(Instance)라 하
며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴
스화(Instantiation)라고 한다.  다형성은 메시지에 의해 객체(클래스)가 연산을 수행하게 
될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지
고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의
미한다.
•  객체(클래스)들은 동일한 메소드명을 사용하며 같은 의
미의 응답을 한다.
•  응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이
상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 
속한 인스턴스처럼 수행할 수 있도록 하는 것이다. 25.2, 24.7, 24.2, 23.7, 23.2, 22.7, 22.4, 21.5
## 25.8, 25.5, 25.2, 24.2, 23.5, 22.3, 21.5, 20.8, 20.624.5, 24.2, 23.5, 22.7, 22.4, 21.5, 21.3, 20.9, 20.8
상속은 이미 정의된 상위 클래스(부모 클래스)의 모든 속성
과 연산을 하위 클래스(자식 클래스)가 물려받는 것이다.
•  상속을 이용하면 하위 클래스는 상위 클래스의 모든 속
성과 연산을 자신의 클래스 내에서 다시 정의하지 않고
서도 즉시 자신의 속성으로 사용할 수 있다. 
•  하위 클래스는 상위 클래스로부터 상속받은 속성과 연산 
외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.24.2, 22.3, 21.8
## 25.8, 24.2, 23.2, 22.4잠깐만요   !  메시지( Message )
메시지는 객체들 간에 상호작용을 하는 데 사용되는 수단으로, 객
체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항입니다.24.7, 22.7, 21.5객체(Object)
2402302
046핵심
클래스(Class)
2402303
047핵심캡슐화(Encapsulation)
2402304
048핵심
상속(Inheritance)
2402305
049핵심
다형성(Polymorphism)
2402306
050핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   17PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   17 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

18
정보처리기사 필기   핵심 요 약
•  예 1 ‘＋’ 연산자의 경우 숫자 클래스에서는 덧셈, 문자 
클래스에서는 문자열의 연결 기능으로 사용된다.
•  예 2 오버로딩(Overloading) 기능의 경우 메소드
(Method)의 이름은 같지만 인수를 받는 자료형과 개수
를 달리하여 여러 기능을 정의할 수 있다.
•  예 3 오버라이딩(Overriding, 메소드 재정의) 기능의 경
우 상위 클래스에서 정의한 메소드(Method)와 이름은 
같지만 메소드 안의 실행 코드를 달리하여 자식 클래스
에서 재정의해서 사용할 수 있다.
객체지향 분석을 위한 여러 방법론이 제시되었으며 각 방
법론은 다음과 같다.
•  Rumbaugh(럼바우) 방법  : 가장 일반적으로 사용되는 방
법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 
나누어 수행하는 방법
•  Booch(부치) 방법  : 미시적(Micro) 개발 프로세스와 거
시적(Macro) 개발 프로세스를 모두 사용하는 분석 방
법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 
속성과 연산을 정의함 럼바우의 분석 기법은 모든 소프트웨어 구성 요소를 그래
픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 
기법(OMT, Object-Modeling Technique)이라고도 한다. 
•  분석 활동은 ‘객체 모델링 → 동적 모델링 → 기능 모델
링’ 순으로 통해 이루어진다.
객체 모델링
(Object 
Modeling)정보 모델링이라고도 하며, 시스템에서 요구되는 객
체를 찾아내어 속성과 연산 식별 및 객체들 간의 관
계를 규정하여 객체 다이어그램으로 표시하는 것
동적 모델링
(Dynamic 
Modeling)상태 다이어그램(상태도)을 이용하여 시간의 흐름에 
따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 
등의 동적인 행위를 표현하는 모델링
기능 모델링
(Functional 
Modeling)자료 흐름도(DFD)를 이용하여 다수의 프로세스들 
간의 자료 흐름을 중심으로 처리 과정을 표현한 모
델링•  Jacobson 방법  : Use Case를 강조하여 사용하는 분석 
방법
•  Coad와 Yourdon 방법  : E-R 다이어그램을 사용하여 객
체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 
정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 
정의 등의 과정으로 구성하는 기법
•  Wirfs-Brock 방법  : 분석과 설계 간의 구분이 없고, 고객 
명세서를 평가해서 설계 작업까지 연속적으로 수행하
는 기법
객체지향 설계 원칙은 시스템 변경이나 확장에 유연한 시
스템을 설계하기 위해 지켜야 할 다섯 가지 원칙으로, 다섯 
가지 원칙의 앞 글자를 따 SOLID 원칙이라고도 불린다.25.5, 25.2, 24.7, 24.2, 23.7, 22.7, 22.3, 21.8, 21.5, 21.3, 20.9, 20.8, 20.6연관성은 두 개 이상의 객체(클래스)들이 상호 참조하는 
관계를 말하며 종류는 다음과 같다. 
종류 의미 특징
is member 
of연관화
(Association)2개 이상의 객체가 상호 관련되어 
있음을 의미함
is instance 
of분류화
(Classfication)동일한 형의 특성을 갖는 객체들을 
모아 구성하는 것
is part of집단화
(Aggregation)관련 있는 객체들을 묶어 하나의 상
위 객체를 구성하는 것
is a일반화
(Generalization)공통적인 성질들로 추상화한 상위 
객체를 구성하는 것
특수화/상세화
(Specialization)상위 객체를 구체화하여 하위 객체
를 구성하는 것25.5, 24.2, 20.6
## 21.3, 20.6
## 25.8, 24.5, 24.2, 23.5, 23.2, 22.7, 22.3, 20.9, 20.8럼바우(Rumbaugh)의  
분석 기법
2402403
053핵심연관성(Relationship)
2402307
051핵심
객체지향 분석의 방법론
2402402
052핵심
객체지향 설계 원칙
2402404
054핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   18PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   18 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

19
정보처리기사 필기   핵심 요 약외부 결합도
(External 
Coupling) 어떤 모듈에서 선언한 데이터(변수)를 외부의 
다른 모듈에서 참조할 때의 결합도
공통(공유) 결합도
(Common 
Coupling) 공유되는 공통 데이터 영역을 여러 모듈이 사
용할 때의 결합도
내용 결합도
(Content 
Coupling) 한 모듈이 다른 모듈의 내부 기능 및 그 내부 
자료를 직접 참조하거나 수정할 때의 결합도단일 책임 원칙
(SRP, Single 
Responsibility 
Principle)객체는 단 하나의 책임만 가져야 한다는 원칙
개방-폐쇄 원칙
(OCP, Open-
Closed Principle) 기존의 코드를 변경하지 않고 기능을 추가할 
수 있도록 설계해야 한다는 원칙
리스코프 치환 
원칙
(LSP, Liskov 
Substitution 
Principle) 자식 클래스는 최소한 자신의 부모 클래스에
서 가능한 행위는 수행할 수 있어야 한다는 설
계 원칙
인터페이스  분리 
원칙
(ISP, Interface 
Segregation 
Principle) 자신이 사용하지 않는 인터페이스와 의존 관
계를 맺거나 영향을 받지 않아야 한다는 원칙
의존 역전 원칙
(DIP, Dependency 
Inversion 
Principle) 각 객체들 간의 의존 관계가 성립될 때, 추상
성이 낮은 클래스보다 추상성이 높은 클래스
와 의존 관계를 맺어야 한다는 원칙
결합도는 모듈 간에 상호 의존하는 정도 또는 두 모듈 사
이의 연관 관계를 의미한다.
•  다양한 결합으로 모듈을 구성할 수 있으나 결합도가 약
할수록 품질이 높고, 강할수록 품질이 낮다.
•  결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.
•  결합도의 종류에는 자료 결합도, 스탬프 결합도, 제어 결
합도, 외부 결합도, 공통 결합도, 내용 결합도가 있으며 
결합도가 약함에서 강함순으로 정리하면 다음과 같다.
자료 결합도
(Data Coupling) 모듈 간의 인터페이스가 자료 요소로만 구성
될 때의 결합도
스탬프(검인) 
결합도
(Stamp Coupling) 모듈 간의 인터페이스로 배열이나 레코드 등
의 자료 구조가 전달될 때의 결합도
제어 결합도
(Control Coupling) 어떤 모듈이 다른 모듈 내부의 논리적인 흐름
을 제어하기 위해 제어 신호를 이용하여 통신
하거나 제어 요소(Function Code, Switch, Tag, 
Flag)를 전달하는 결합도응집도는 정보 은닉 개념을 확장한 것으로, 명령어나 호
출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 
즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
한다.
•   다양한 기준으로 모듈을 구성할 수 있으나 응집도가 강
할수록 품질이 높고, 약할수록 품질이 낮다.
•   응집도의 종류에는 기능적 응집도, 순차적 응집도, 교
환(통신)적 응집도, 절차적 응집도, 시간적 응집도, 논
리적 응집도, 우연적 응집도가 있으며 응집도가 강함에
서 약함순으로 정리하면 다음과 같다. 
기능적 응집도 
(Functional 
Cohesion) 모듈 내부의 모든 기능 요소들이 단일 문제와 
연관되어 수행될 경우의 응집도
순차적 응집도 
(Sequential 
Cohesion)모듈 내 하나의 활동으로부터 나온 출력 데이터
를 그 다음 활동의 입력 데이터로 사용할 경우
의 응집도
교환(통신)적 
응집도 
(Communication 
Cohesion) 동일한 입력과 출력을 사용하여 서로 다른 기능
을 수행하는 구성 요소들이 모였을 경우의 응집
도
절차적 응집도 
(Procedural 
Cohesion) 모듈이 다수의 관련 기능을 가질 때 모듈 안의 
구성 요소들이 그 기능을 순차적으로 수행할 경
우의 응집도
시간적 응집도 
(Temporal 
Cohesion) 특정 시간에 처리되는 몇 개의 기능을 모아 하
나의 모듈로 작성할 경우의 응집도
논리적 응집도 
(Logical 
Cohesion) 유사한 성격을 갖거나 특정 형태로 분류되는 처
리 요소들로 하나의 모듈이 형성되는 경우의 응
집도
우연적 응집도 
(Coincidental 
Cohesion) 모듈 내부의 각 구성 요소들이 서로 관련 없는 
요소로만 구성된 경우의 응집도25.8, 25.2, 24.5, 23.7, 23.2, 22.7, 22.4, 21.5, 21.3, 20.9, 20.8, 20.625.8, 24.5, 23.5, 22.4, 21.8, 21.5, 21.3, 20.9, 20.8, 20.6
결합도(Coupling)
2402502
055핵심응집도(Cohesion)
2402503
056핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   19PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   19 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

20
정보처리기사 필기   핵심 요 약
•  팬인은 어떤 모듈을 제어(호출)하는 모듈의 수를 나타
낸다.
•  팬아웃은 어떤 모듈에 의해 제어(호출)되는 모듈의 수
를 나타낸다.
예제  다음의 시스템 구조도에서 각 모듈의 팬인(Fan-In)과 
팬아웃(Fan-Out)을 구하시오.
A
B
HEC
IFD
G
해설
팬인(Fan-In)  : A는 0, B·C·D·E·G는 1, F·H·I는 2
팬아웃(Fan-Out)  : H·I는 0, C·E·F·G는 1, B·D는 2, A
는 3
N-S 차트는 논리의 기술에 중점을 둔 도형을 이용한 표현 
방법으로 박스 다이어그램, Chapin Chart라고도 한다.
•  연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 
표현한다.
• GOTO나 화살표를 사용하지 않는다.
•  조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 
식별하는 데 적합하다.
• 선택과 반복 구조를 시각적으로 표현한다.
• 이해하기 쉽고, 코드 변환이 용이하다.
•  읽기는 쉽지만 작성하기가 어려우며, 임의로 제어를 전
이하는 것이 불가능하다.
•  총체적인 구조 표현과 인터페이스를 나타내기가 어렵다.
• 단일 입구와 단일 출구로 표현한다. 공통 모듈은 여러 프로그램에서 공통적으로 사용할 수 있
는 모듈을 의미한다.
•  자주 사용되는 계산식이나 매번 필요한 사용자 인증과 
같은 기능들이 공통 모듈로 구성될 수 있다.
•  모듈의 재사용성 확보와 중복 개발 회피를 위해 설계 
과정에서 공통 부분을 식별하고 명세를 작성할 필요가 
있다.
•  공통 모듈을 구현할 때는 다른 개발자들이 해당 기능을 
명확히 이해할 수 있도록 다음의 명세 기법을 준수해야 
한다. 
정확성
(Correctness)시스템 구현 시 해당 기능이 필요하다는 것을 
알 수 있도록 정확히 작성함
명확성(Clarity)해당 기능을 이해할 때 중의적으로 해석되지 않
도록 명확하게 작성함
완전성
(Completeness)시스템 구현을 위해 필요한 모든 것을 기술함
일관성
(Consistency)공통 기능들 간 상호 충돌이 발생하지 않도록 
작성함
추적성
(Traceability)기능에 대한 요구사항의 출처, 관련 시스템 등의 
관계를 파악할 수 있도록 작성함
재사용은 비용과 개발 시간을 절약하기 위해 이미 개발된 
기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 
개발에 사용하기 적합하도록 최적화 시키는 작업이다.
•  재사용을 위해서는 누구나 이해할 수 있고 사용이 가능
하도록 사용법을 공개해야 한다.
•  재사용되는 대상은 외부 모듈과의 결합도는 낮고, 응집
도는 높아야 한다.
• 재사용 규모에 따른 분류  
함수와 객체 클래스나 메소드 단위의 소스 코드를 재사용함
컴포넌트• 독립적인 업무 또는 기능을 수행하는 실행 코드 
기반으로 작성된 모듈임
• 컴포넌트 자체에 대한 수정 없이 인터페이스를 
통해 통신하는 방식으로 재사용함
애플리케이션공통된 기능들을 제공하는 애플리케이션을 공유하
는 방식으로 재사용함22.7, 21.3 20.6
## 22.4, 21.3, 20.9
## 25.5, 24.2, 22.3, 20.9팬인(Fan-In) /  
팬아웃(Fan-Out)
2402504
057핵심
N-S 차트(Nassi-  
Schneiderman Chart)
2402531
058핵심공통 모듈의 개요
2402601
059핵심
재사용(Reuse)
2402602
060핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   20PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   20 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

21
정보처리기사 필기   핵심 요 약•  결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재
사용성을 높인다.
•  모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지
시킨다.
• 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
•  모듈의 기능은 예측이 가능해야 하며 지나치게 제한적
이어서는 안 된다.
• 유지보수가 용이해야 한다.
•  모듈 크기는 시스템의 전반적인 기능과 구조를 이해하
기 쉬운 크기로 분해한다.
•  효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하
는 자료가 제시되어야 한다.
코드는 컴퓨터를 이용하여 자료를 처리하는 과정에서 분
류·조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽
게 하기 위해서 사용하는 기호이다. 
•  코드는 정보를 신속·정확·명료하게 전달할 수 있게 한
다.
•  일반적인 코드의 예로 주민등록번호, 학번, 전화번호 
등이 있다.
•  코드의 주요 기능에는 식별 기능, 분류 기능, 배열 기
능, 표준화 기능, 간소화 기능이 있다.
식별 기능 데이터 간의 성격에 따라 구분이 가능함
분류 기능특정 기준이나 동일한 유형에 해당하는 데이터를 그
룹화 할 수 있음
배열 기능 의미를 부여하여 나열할 수 있음
표준화 기능 다양한 데이터를 기준에 맞추어 표현할 수 있음
간소화 기능 복잡한 데이터를 간소화할 수 있음코드의 종류에는 다음과 같은 것들이 있다. 
순차 코드
(Sequence 
Code)자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 
최초의 자료부터 차례로 일련번호를 부여하는 방법
으로, 순서 코드 또는 일련번호 코드라고도 함
 1, 2, 3, 4, …
블록 코드
(Block Code)코드화 대상 항목 중에서 공통성이 있는 것끼리 
블록으로 구분하고, 각 블록 내에서 일련번호를 
부여하는 방법으로, 구분 코드라고도 함
 1001~1100 : 총무부, 1101~1200 : 영업부
10진 코드
(Decimal 
Code)코드화 대상 항목을 0~9까지 10진 분할하고, 다
시 그 각각에 대하여 10진 분할하는 방법을 필요
한 만큼 반복하는 방법으로, 도서 분류식 코드라
고도 함
  1000 : 공학, 1100 : 소프트웨어 공학, 1110 : 소프
트웨어 설계
그룹 분류 코드
(Group 
Classification 
Code)코드화 대상 항목을 일정 기준에 따라 대분류, 중
분류, 소분류 등으로 구분하고, 각 그룹 안에서 일
련번호를 부여하는 방법
  1-01-001 : 본사-총무부-인사계, 2-01-001 : 
지사-총무부-인사계
연상 코드
(Mnemonic 
Code)코드화 대상 항목의 명칭이나 약호와 관계있는 숫
자나 문자, 기호를 이용하여 코드를 부여하는 방법
  TV-40 : 40인치 TV, L-15-220 : 15W 220V의 
램프
표의 숫자 코드
(Significant 
Digit Code)코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지
름, 높이 등의 물리적 수치를 그대로 코드에 적용
시키는 방법으로, 유효 숫자 코드라고도 함
  120-720-1500 : 두께×폭×길이가 120×720×
1500인 강판
합성 코드
(Combined 
Code)필요한 기능을 하나의 코드로 수행하기 어려운 경
우 2개 이상의 코드를 조합하여 만드는 방법
 연상 코드 + 순차 코드
   KE-711 : 대한항공 711기, AC-253 : 에어캐나다 
253기24.7, 22.3, 21.3, 20.9, 20.8
## 20.823.7, 23.2, 20.9, 20.6
효과적인 모듈 설계 방안
2402603
061핵심
코드(Code)의 개요
2402701
062핵심코드의 종류
2402702
063핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   21PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   21 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

22
정보처리기사 필기   핵심 요 약
 디자인 패턴은 각 모듈의 세분화된 역할이나 모듈들 간의 
인터페이스와 같은 코드를 작성하는 수준의 세부적인 구
현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 
또는 예제를 의미한다.
•  디자인 패턴은 문제 및 배경, 실제 적용된 사례, 재사용
이 가능한 샘플 코드 등으로 구성되어 있다.
•  ‘바퀴를 다시 발명하지 마라(Don't reinvent the 
wheel)’라는 말과 같이, 개발 과정 중에 문제가 발생하
면 새로 해결책을 구상하는 것보다 문제에 해당하는 디
자인 패턴을 참고하여 적용하는 것이 더 효율적이다.
•  GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 
패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.추상 
팩토리
(Abstract 
Factory)• 구체적인 클래스에 의존하지 않고, 인터페이스를 
통해 서로 연관·의존하는 객체들의 그룹으로 생성
하여 추상적으로 표현함
• 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 
가능함
빌더
(Builder)• 작게 분리된 인스턴스를 건축 하듯이 조합하여 객
체를 생성함
• 객체의 생성 과정과 표현 방법을 분리하고 있어, 동
일한 객체 생성에서도 서로 다른 결과를 만들어 낼 
수 있음
팩토리 
메소드
(Factory 
Method)• 객체 생성을 서브 클래스에서 처리하도록 분리하여 
캡슐화한 패턴
• 상위 클래스에서 인터페이스만 정의하고 실제 생성
은 서브 클래스가 담당함
•가상 생성자(Virtual Constructor) 패턴이라고도 함
프로토타입
(Prototype)• 원본 객체를 복제하는 방법으로 객체를 생성하는 
패턴
• 일반적인 방법으로 객체를 생성하며, 비용이 큰 경
우 주로 이용함
싱글톤
(Singleton)• 하나의 객체를 생성하면 생성된 객체를 어디서든 
참조할 수 있지만, 여러 프로세스가 동시에 참조할 
수는 없음
• 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 
불필요한 메모리 낭비를 최소화 할 수 있음
생성 패턴은 객체의 생성과 관련된 패턴으로 총 5개의 패
턴이 있다.
•  생성 패턴은 객체의 생성과 참조 과정을 캡슐화 하여 
객체가 생성되거나 변경되어도 프로그램의 구조에 영
향을 크게 받지 않도록 하여 프로그램에 유연성을 더해
준다.  구조 패턴은 클래스나 객체들을 조합하여 더 큰 구조로 만
들 수 있게 해주는 패턴으로 총 7개의 패턴이 있다. 
•  구조 패턴은 구조가 복잡한 시스템을 개발하기 쉽게 도
와준다. 
어댑터
(Adapter)• 호환성이 없는 클래스들의 인터페이스를 다른 클
래스가 이용할 수 있도록 변환해주는 패턴
• 기존의 클래스를 이용하고 싶지만 인터페이스가 
일치하지 않을 때 이용함
브리지
(Bridge)• 구현부에서 추상층을 분리하여, 서로가 독립적으
로 확장할 수 있도록 구성한 패턴
•기능과 구현을 두 개의 별도 클래스로 구현함
컴포지트
(Composite)• 여러 객체를 가진 복합 객체와 단일 객체를 구분 
없이 다루고자 할 때 사용하는 패턴
• 객체들을 트리 구조로 구성하여 디렉터리 안에 
디렉터리가 있듯이 복합 객체 안에 복합 객체가 
포함되는 구조를 구현할 수 있음25.8, 24.7, 23.5, 22.3, 20.9, 20.8
•  범용적인 코딩 스타일로 인해 구조 파악이 용이하다.
• 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.
•  검증된 구조의 재사용을 통해 개발 시간과 비용이 절약
된다.
• 초기 투자 비용이 부담될 수 있다.
• 개발자 간의 원활한 의사소통이 가능하다.
• 설계 변경 요청에 대한 유연한 대처가 가능하다.
•  객체지향을 기반으로 한 설계와 구현을 다루므로 다른 
기반의 애플리케이션 개발에는 적합하지 않다.25.2, 21.3, 20.9
## 25.5, 25.2, 24.5, 24.2, 23.7, 23.5, 23.2, 22.7, 22.3, 21.8, 21.5, 21.3, 20.825.8, 25.5, 23.7, 23.2, 22.4, 21.5디자인 패턴  
(Design Pattern)의 개요
2402801
064핵심
생성 패턴  
(Creational Pattern)
2402803
066핵심구조 패턴  
(Structural Pattern) 
2402804
067핵심디자인 패턴 사용의 장·단점
2402802
065핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   22PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   22 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

25
정보처리기사 필기   핵심 요 약배열(Array)
스택(Stack)
데크(Deque)
그래프(Graph)선형 리스트(Linear List)
큐(Queue)
트리(Tree)비선형 구조
(Non-Linear 
Structure)선형 구조
(Linear 
Structure)연결 리스트  
(Linked List)연속 리스트  
(Contiguous List)
연속 리스트(Contiguous List)
•  연속 리스트는 배열과 같이 연속되는 기억장소에 저장
되는 자료 구조이다.
•  연속 리스트는 기억장소를 연속적으로 배정받기 때문
에 기억장소 이용 효율은 밀도가 1로서 가장 좋다.
•  연속 리스트는 중간에 데이터를 삽입하기 위해서는 연
속된 빈 공간이 있어야 하며, 삽입·삭제 시 자료의 이
동이 필요하다.
연결 리스트(Linked List)
•  연결 리스트는 자료들을 반드시 연속적으로 배열시키
지는 않고 임의의 기억공간에 기억시키되, 자료 항목의 
순서에 따라 노드의 포인터 부분을 이용하여 서로 연결
시킨 자료 구조이다.
•  연결 리스트는 노드의 삽입·삭제 작업이 용이하다.
•  기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 
있다.
•  연결 리스트는 연결을 위한 링크(포인터) 부분이 필요
하기 때문에 순차 리스트에 비해 기억 공간의 이용 효
율이 좋지 않다.
•  연결 리스트는 연결을 위한 포인터를 찾는 시간이 필요
하기 때문에 접근 속도가 느리다.
•  연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노
드를 찾기 힘들다. 스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업
이 이루어지는 자료 구조이다.
•  스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 
후입선출(LIFO; Last In First Out) 방식으로 자료를 
처리한다.
• 스택의 응용 분야  
 - 함수 호출의 순서 제어
 - 인터럽트의 처리
 - 수식 계산 및 수식 표기법
 - 컴파일러를 이용한 언어 번역
 - 부 프로그램 호출 시 복귀주소 저장
 - 서브루틴 호출 및 복귀 주소 저장
•  스택의 모든 기억 공간이 꽉 채워져 있는 상태에서 데
이터가 삽입되면 오버플로(Overflow)가 발생하며, 더 
이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하
면 언더플로(Underflow)가 발생한다.
예제  순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력
하였다가 B, C, D, A 순서로 출력하는 과정을 나열하시오.
PUSH 
APUSH 
BPOP 
B PUSH 
CPOP 
CPUSH 
DPOP 
DPOP 
A
→→B→→ →→C→→ →→D→→ →→
A A A A A A A
B BC BCD BCDA
큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 
한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조
이다.
•  큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선
입선출(FIFO; First In First Out) 방식으로 처리한다.
• 큐는 시작과 끝을 표시하는 두 개의 포인터가 있다.소프트웨어 개발 2과목
## 25.5, 24.7, 24.2, 23.7, 22.3, 21.8, 21.3
## 25.5, 22.725.8, 25.5, 25.2, 23.7, 23.2, 22.7, 22.4, 22.3, 21.8, 21.5, 21.3
## 21.3자료 구조의 분류
2403602
073핵심
선형 리스트(Linear List)
2403604
074핵심스택(Stack)
2403605
075핵심
큐(Queue)
2403606
076핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   25PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   25 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

26
정보처리기사 필기   핵심 요 약
n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수
는 n(n-1)/2이고, 방향 그래프에서 최대 간선 수는 n(n-
1)이다.
 정점이 4개인 경우 무방향 그래프와 방향 그래프의 최
대 간선 수는 다음과 같다.
A
CB
D  
• 무방향 그래프의 최대 간선 수 : 4(4-1)/2 = 6
A
CB
D  
• 방향 그래프의 최대 간선 수  : 4(4-1) = 12 - 디그리(Degree, 차수)  : 각 노드에서 뻗어 나온 가지의 수
   A = 3, B = 2, C = 1, D = 3
 -  단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식
이 하나도 없는 노드, 즉 디그리가 0인 노드
   K, L, F, G, M, I, J
 -  자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨
의 노드들
   D의 자식 노드 : H, I, J
 -  부모 노드(Parent Node)  : 어떤 노드에 연결된 이전 레
벨의 노드들
   E, F의 부모 노드 : B
 -  형제 노드(Brother Node, Sibling)  : 동일한 부모를 갖는 
노드들
   H의 형제 노드 : I, J
 - 트리의 디그리  : 노드들의 디그리 중에서 가장 많은 수
    노드 A나 D가 3개의 디그리를 가지므로 앞 트리
의 디그리는 3이다.
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하
여 사이클을 이루지 않도록 구성한 그래프(Graph)의 특
수한 형태이다.
• 트리 관련 용어
Level 1
Level 2
Level 3
Level 4 → Depth KGC
I
LF H
MJD B
EA
 -   노드(Node) : 트리의 기본 요소로서 자료 항목과 다른 
항목에 대한 가지(Branch)를 합친 것
   A, B, C, D, E, F, G, H, I, J, K, L, M
 -   근 노드(Root Node)  : 트리의 맨 위에 있는 노드    
   A "
# $  
•  Preorder 운행  : Root → Left → Right 순으로 운행.  
A, B, C
•  Inorder 운행  : Left → Root → Right 순으로 운행.  
B, A, C
•  Postorder 운행  : Left → Right → Root 순으로 운행.  
B, C, A
예제  다음 트리를 Inorder, Preorder, Postorder 방법으로 운
행했을 때 각 노드를 방문한 순서는?
#"
$
' ( % &
) *23.2, 20.9
## 25.8, 24.7, 23.7, 23.2, 21.3, 20.8, 20.325.8, 25.5, 25.2, 24.7, 24.5, 24.2, 23.5, 22.7, 22.4, 21.8, 21.3, 20.9, 20.8, 20.6방향/무방향 그래프의  
최대 간선 수
2403631
077핵심
트리의 개요
2403701
078핵심트리의 운행법
2403702
079핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   26PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   26 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

27
정보처리기사 필기   핵심 요 약Preorder 운행법의 방문 순서
※  서브 트리를 하나의 노드로 생각할 수 있도록 그림
과 같이 서브트리 단위로 묶는다. Preorder, Inorder, 
Postorder 모두 공통으로 사용한다.
#"
$
' ( % &
) *1
23
❶   Preorder는 Root → Left → Right이므로 A13이 된다.
❷   1은 B2E이므로 A B2E3이 된다.
❸   2는 DHI이므로 AB DHIE3이 된다.
❹   3은 CFG이므로 ABDHIE CFG가 된다.
• 방문 순서  : ABDHIECFG
Inorder 운행법의 방문 순서
❶ Inorder는 Left → Root → Right이므로 1A3이 된다.
❷ 1은 2BE이므로 2BEA3이 된다.
❸ 2는 HDI이므로 HDIBEA3이 된다.
❹ 3은 FCG이므로 HDIBEA FCG가 된다.
• 방문 순서  : HDIBEAFCG
Postorder
❶  Postorder는 Left → Right → Root이므로 13A가  
된다.
❷ 1은 2EB이므로 2EB3A가 된다.
❸ 2는 HID이므로 HIDEB3A가 된다.
❹ 3은 FGC이므로 HIDEB FGCA가 된다.
• 방문 순서  : HIDEBFGCA

" #
• 전위 표기법(PreFix)  : 연산자 → Left → Right, +AB
• 중위 표기법(InFix)  : Left → 연산자 → Right, A+B
• 후위 표기법(PostFix)  : Left → Right → 연산자, AB+
Infix 표기를 Postfix나 Prefix로 바꾸기
 Postfix나 Prefix는 스택을 이용하여 처리하므로 Infix는 
Postfix나 Prefix로 바꾸어 처리한다.
예제 1  다음과 같이 Infix로 표기된 수식을 Prefix와 Postfix로 변
환하시오.
X = A / B * (C + D) + E
• Prefix로 변환하기
 ❶ 연산 우선순위에 따라 괄호로 묶는다.
   ( X = ( ( (A / B) * (C + D) ) + E ) )
 ❷ 연산자를 해당 괄호의 앞(왼쪽)으로 옮긴다.
    X  =  (  (  (A  /  B) *  (C + D)  ) + E  )  )   
= ( X + ( * ( / (AB) + (CD) ) E) )
 ❸ 필요없는 괄호를 제거한다.
   = X + * / A B + C D E
• Postfix로 변환하기
 ❶ 연산 우선순위에 따라 괄호로 묶는다.
   ( X = ( ( (A / B) * (C + D) ) + E ) ) 
 ❷ 연산자를 해당 괄호의 뒤(오른쪽)로 옮긴다.
    ( X  =  (  (  (A  /  B) * (C + D)  )  + E  )  )   
( X ( ( (A B) / (C D) + ) * E ) + ) =
 ❸ 필요 없는 괄호를 제거한다.
   X A B / C D + * E + = 24.5, 21.5, 21.3, 20.9
수식의 표기법
2403703
080핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   27PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   27 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

28
정보처리기사 필기   핵심 요 약
Postfix나 Prefix로 표기된 수식을 Infix로 바꾸기
예제 2  다음과 같이 Postfix로 표기된 수식을 Infix로 변환하  
시오.
A  B  C -  /  D  E  F  +  *  +
 Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 
개의 뒤로 이동한 것이므로 연산자를 다시 해당 피연산자 
두 개의 가운데로 옮기면 된다.
❶  먼저 인접한 피연산자 두 개와 오른쪽의 연산자를 괄호
로 묶는다.
  ( (A (B C -) /) (D (E F +) *) + )
❷ 연산자를 해당 피연산자의 가운데로 이동시킨다.
   (  (A  (B  C  -)  /  )  (D  (E  F  + ) * )  + )   
((A / (B - C)) + (D * (E + F)))
❸ 필요 없는 괄호를 제거한다.
   ((A / (B - C)) + (D * (E + F)))   
A / (B - C) + D * (E + F)
예제 3  다음과 같이 Prefix로 표기된 수식을 Infix로 변환하  
시오.
+  /  A  -  B  C  *  D  +  E  F
Prefix는 Infix 표기법에서 연산자를 해당 피연산자 두 개
의 앞으로 이동한 것이므로 연산자를 다시 해당 피연산자 
두 개의 가운데로 옮기면 된다.
❶  먼저 인접한 피연산자 두 개와 왼쪽의 연산자를 괄호로 
묶는다.
  (+ (/ A (- B C) ) ( * D (+ E F) ) )
❷ 연산자를 해당 피연산자 사이로 이동시킨다.
   ( +  ( / A  ( - B  C) )  ( * D  ( + E  F)  )  )   
((A/(B-C)) + (D * (E+F)))
❸ 필요 없는 괄호를 제거한다.
  ((A/(B-C)) + (D *(E+F)))  A/(B-C)+D *(E+F)예제  8, 5, 6, 2, 4를 삽입 정렬로 정렬하시오.
•초기 상태  :85624
•1회전 :85624 58624
두 번째 값을 첫 번째 값과 비교하여 5를 첫 번째 자리에 삽입하고 
8을 한 칸 뒤로 이동시킨다.
•2회전 :58624 56824
세 번째 값을 첫 번째, 두 번째 값과 비교하여 6을 8자리에 삽입하
고 8을 한 칸 뒤로 이동시킨다.
56824 25684
네 번째 값 2를 처음부터 비교하여 맨 처음에 삽입하고 나머지를 
한 칸씩 뒤로 이동시킨다.
•4회전 :25684 24568
다섯 번째 값 4를 처음부터 비교하여 5자리에 삽입하고 나머지를 
한 칸씩 뒤로 이동시킨다.
예제  8, 5, 6, 2, 4를 선택 정렬로 정렬하시오.
• 초기 상태 :85624
 
• 1회전 :856248562425684
첫 번째부터 마지막 값 중 최소값 2를 찾아 첫 번째 값 8과 위치를 
교환한다.
 
• 2회전 :256842568424685
두 번째부터 마지막 값 중 최소값 4를 찾아 두 번째 값 5와 위치를 
교환한다.
• 3회전 :246852468524586
세 번째부터 마지막 값 중 최소값 5를 찾아 세 번째 값 6과 위치를 
교환한다.
• 4회전 :245862458624568
네 번째부터 마지막 값 중 최소값 6을 찾아 네 번째 값 8과 위치를 
교환환다.25.8, 24.2, 20.9
## 25.5, 24.7, 24.5, 22.7, 21.3, 20.8삽입 정렬(Insertion Sort)
2403801
081핵심
선택 정렬(Selection Sort)
2403803
082핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   28PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   28 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

29
정보처리기사 필기   핵심 요 약힙 정렬은 전이진 트리(Complete Binary Tree)를 이용한 
정렬 방식이다.
• 구성된 전이진 트리를 Heap Tree로 변환하여 정렬한다.
• 평균과 최악 모두 시간 복잡도는 O(nlog2n)이다.예제  8, 5, 6, 2, 4를 버블 정렬로 정렬하시오.
•초기 상태  :85624
•1회전 :586245682456284
56248
•2회전 :562485264852468
•3회전 :2546824568
•4회전 :245682-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 
한 개의 파일로 합병하는 정렬 방식이다. 
• 평균과 최악 모두 시간 복잡도는 O(nlog2n)이다.
•  제산법(Division)  : 레코드 키(K)를 해시표(Hash Table)
의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 
나눈 나머지를 홈 주소로 삼는 방식, 즉 h(K) = K mod 
Q임
•  제곱법(Mid-Square)  : 레코드 키 값(K)을 제곱한 후 그 
중간 부분의 값을 홈 주소로 삼는 방식
•  폴딩법(Folding)  : 레코드 키 값(K)을 여러 부분으로 나눈 
후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값
을 홈 주소로 삼는 방식
•  기수 변환법(Radix) : 키 숫자의 진수를 다른 진수로 변환
시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이
를 다시 주소 범위에 맞게 조정하는 방법 2-Way 합병 정렬  
(Merge Sort)
2403807
086핵심
해싱 함수  
(Hashing Function)
2403902
088핵심21.5
## 24.7, 24.2, 22.7, 21.3, 20.925.2, 23.2, 22.4, 21.8, 21.5
퀵 정렬은 레코드의 많은 자료 이동을 없애고 하나의 파일
을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기
준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분
해시키는 방식으로 정렬한다.
• 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬한다.
•  평균 수행 시간 복잡도는 O(nlog2n)이고, 최악의 수행 
시간 복잡도는 O(n2)이다.25.5, 24.2, 23.5, 23.2, 22.3, 21.3
## 25.8, 24.2, 23.5, 21.5이분 검색(이진 검색, Binary Search)은 전체 파일을 두 
개의 서브파일로 분리해 가면서 Key 레코드를 검색하는 
방식이다.
• 이분 검색은 반드시 순서화된 파일이어야 검색할 수 있다.
•  찾고자 하는 Key 값을 파일의 중간 레코드 Key 값과 
비교하면서 검색한다.
•  비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 
수가 절반으로 줄어듦으로 탐색 효율이 좋고 탐색 시간
이 적게 소요된다.
•  중간 레코드 번호 M = (F+L)
2 (단, F : 첫 번째 레코드 
번호, L : 마지막 레코드 번호)25.8, 23.7, 22.4, 21.3버블 정렬(Bubble Sort)
2403804
083핵심
퀵 정렬(Quick Sort)
2403805
084핵심
힙 정렬(Heap Sort)
2403806
085핵심이분 검색
2403901
087핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   29PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   29 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

32
정보처리기사 필기   핵심 요 약
 통합 개발 환경은 코딩, 디버그, 컴파일, 배포 등 프로그
램 개발과 관련된 모든 작업을 하나의 프로그램에서 처
리할 수 있도록 제공하는 소프트웨어적인 개발 환경을 말  
한다.
•  기존 소프트웨어 개발에서는 편집기(Editor), 컴파일러
(Compiler), 디버거(Debugger) 등의 다양한 툴을 별도
로 사용했으나 현재는 하나의 인터페이스로 통합하여 
제공한다. 
•  통합 개발 환경 도구는 통합 개발 환경을 제공하는 소
프트웨어를 의미한다.
•  통합 개발 환경을 지원하는 도구는 플랫폼, 운영체제, 
언어별로 다양하게 존재한다.
• 통합 개발 환경 도구의 대표적인 기능
코딩
(Coding)C, JAVA 등의 프로그래밍 언어로 프로그램을 작성
하는 기능
컴파일
(Compile)개발자가 작성한 고급 언어로 된 프로그램을 컴퓨
터가 이해할 수 있는 목적 프로그램으로 번역하여 
컴퓨터에서 실행 가능한 형태로 변환하는 기능
디버깅
(Debugging)소프트웨어나 하드웨어의 오류나 잘못된 동작, 즉 
버그(Bug)를 찾아 수정하는 기능
배포
(Deployment)소프트웨어를 사용자에게 전달하는 기능
 빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 
제품 소프트웨어로 변환하는 과정 또는 결과물을 말한다.
•  빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정
에 필요한 전처리(Preprocessing), 컴파일(Compile) 등
의 작업들을 수행하는 소프트웨어를 말한다.
• 대표적인 도구로는 Ant, Maven, Gradle 등이 있다.
Ant아파치 소프트웨어 재단(Apache Software Foundation)에
서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 
도구로 사용되고 있음
MavenAnt와 동일한 아파치 소프트웨어 재단에서 개발된 것으
로, Ant의 대안으로 개발되었음
Gradle기존의 Ant와 Maven을 보완하여 개발된 빌드 도구로, 한
스 도커(Hans Dockter) 외 6인의 개발자가 모여 공동 개
발하였음소프트웨어 패키징이란 모듈별로 생성한 실행 파일들을 
묶어 배포용 설치 파일을 만드는 것을 말한다.
• 개발자가 아니라 사용자를 중심으로 진행한다.
•  소스 코드는 향후 관리를 고려하여 모듈화하여 패키징
한다.
•  사용자가 소프트웨어를 사용하게 될 환경을 이해하여, 
다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도
록 일반적인 배포 형태로 패키징한다.통합 개발 환경(IDE; Integrated 
Development Environment)
2404501
097핵심
•  사용자의 시스템 환경, 즉 운영체제(OS), CPU, 메모리 
등에 필요한 최소 환경을 정의한다.
•  UI(User Interface)는 사용자가 눈으로 직접 확인할 수 
있도록 시각적인 자료와 함께 제공하고 매뉴얼과 일치
시켜 패키징한다.
•  소프트웨어는 단순히 패키징하여 배포하는 것으로 끝
나는 것이 아니라 하드웨어와 함께 관리될 수 있도록 
Managed Service 형태로 제공하는 것이 좋다.
•  사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 
대한 암호화 및 보안을 고려한다.
•  다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관
리) 연동을 고려한다.
•  사용자의 편의성을 위한 복잡성 및 비효율성 문제를 고
려한다.
•  제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적
용한다.25.2, 23.7, 23.2, 22.4
## 23.5, 22.325.2, 23.2, 22.7, 22.3, 21.5
## 24.2, 20.9, 20.8, 20.6
빌드 도구
2404502
098핵심소프트웨어 패키징의 개요
2404601
099핵심
패키징 시 고려사항
2404602
100핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   32PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   32 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

35
정보처리기사 필기   핵심 요 약21.8, 21.3
형상 관리(SCM; Software Configuration Management)
는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항
을 관리하기 위해 개발된 일련의 활동이다.
•  소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 
변경되고 있는지 확인하여 해당 담당자에게 통보한다.
•  형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활
동이며, 유지보수 단계에서도 수행된다.
•  형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 
개발 과정의 여러 방해 요인이 최소화되도록 보증하는 
것을 목적으로 한다.
•  관리 항목에는 소스 코드뿐만 아니라 각종 정의서, 지
침서, 분석서 등이 포함된다.
•  형상 관리를 통해 가시성과 추적성을 보장함으로써 소
프트웨어의 생산성과 품질을 높일 수 있다.
•  대표적인 형상 관리 도구에는 Git, CVS, Subversion 
등이 있다.
•  지속적인 소프트웨어의 변경 사항을 체계적으로 추적
하고 통제할 수 있다.
•  제품 소프트웨어에 대한 무절제한 변경을 방지할 수  
있다.
•  제품 소프트웨어에서 발견된 버그나 수정 사항을 추적
할 수 있다.
•  소프트웨어는 형태가 없어 가시성이 결핍되므로 진행 
정도를 확인하기 위한 기준으로 사용될 수 있다.
• 소프트웨어의 배포본을 효율적으로 관리할 수 있다.
•  소프트웨어를 여러 명의 개발자가 동시에 개발할 수  
있다.항목 설명
저장소
(Repository)최신 버전의 파일들과 변경 내역에 대한 정보들이 
저장되어 있는 곳
가져오기
(Import)버전 관리가 되고 있지 않은 아무것도 없는 저장소
(Repository)에 처음으로 파일을 복사 함
체크아웃
(Check-Out)• 프로그램을 수정하기 위해 저장소(Repository)에
서 파일을 받아옴
• 소스 파일과 함께 버전 관리를 위한 파일들도 받
아옴
체크인
(Check-In)체크아웃 한 파일의 수정을 완료한 후 저장소
(Repository)의 파일을 새로운 버전으로 갱신 함
커밋
(Commit)체크인을 수행할 때 이전에 갱신된 내용이 있는 경
우에는 충돌(Conflict)을 알리고 diff 도구를 이용해 
수정한 후 갱신을 완료 함
동기화
(Update)저장소에 있는 최신 버전으로 자신의 작업 공간을 
동기화함•  형상 식별  : 형상 관리 대상에 이름과 관리 번호를 부여
하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이
하도록 하는 작업
•  버전 제어  : 소프트웨어 업그레이드나 유지 보수 과정에
서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위
해 특정 절차와 도구(Tool)를 결합시키는 작업
•  형상 통제(변경 관리)  : 식별된 형상 항목에 대한 변경 요
구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 
수 있도록 조정하는 작업
•  형상 감사  : 기준선의 무결성을 평가하기 위해 확인, 검
증, 검열 과정을 통해 공식적으로 승인하는 작업
•  형상 기록(상태 보고)  : 형상의 식별, 통제, 감사 작업의 
결과를 기록·관리하고 보고서를 작성하는 작업
## 20.825.8, 25.2, 23.7, 22.7, 22.4, 21.8, 21.5, 21.3, 20.9, 20.6
## 24.7, 24.2, 23.2, 21.5, 20.8소프트웨어 패키징의  
형상 관리
2405101
109핵심
소프트웨어의 버전 등록 관련  
주요 기능
2405104
112핵심
형상 관리의 중요성
2405102
110핵심형상 관리 기능
2405103
111핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   35PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   35 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

38
정보처리기사 필기   핵심 요 약
화이트박스 테스트는 모듈의 원시 코드를 오픈시킨 상태
에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스
트 케이스를 설계하는 방법이다. 
• 모듈 안의 작동을 직접 관찰한다. 
•  원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로
써 수행된다. 
•  프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 
부분들을 수행함으로써 논리적 경로를 제어한다.정적 
테스트• 프로그램을 실행하지 않고 명세서나 소스 코드를 대상
으로 분석하는 테스트
• 소프트웨어 개발 초기에 결함을 발견할 수 있어 소프
트웨어의 개발 비용을 낮추는데 도움이 됨
• 종류 : 워크스루, 인스펙션, 코드 검사 등
동적 
테스트• 프로그램을 실행하여 오류를 찾는 테스트로, 소프트웨
어 개발의 모든 단계에서 테스트를 수행할 수 있음
• 종류 : 블랙박스 테스트, 화이트박스 테스트
검증
(Verification) 
테스트개발자의 시각에서 제품의 생산 과정을 테스트하
는 것으로, 제품이 명세서대로 완성됐는지를 테스트  
함
확인
(Validation) 
테스트사용자의 시각에서 생산된 제품의 결과를 테스트하
는 것으로, 사용자가 요구한대로 제품이 완성됐는
지, 제품이 정상적으로 동작하는지를 테스트함회복
(Recovery) 
테스트시스템에 여러 가지 결함을 주어 실패하도록 한 
후 올바르게 복구되는지를 확인하는 테스트
안전(Security) 
테스트시스템에 설치된 시스템 보호 도구가 불법적인 
침입으로부터 시스템을 보호할 수 있는지를 확인
하는 테스트
강도(Stress) 
테스트시스템에 과도한 정보량이나 빈도 등을 부과하여 
과부하 시에도 소프트웨어가 정상적으로 실행되
는지를 확인하는 테스트
성능
(Performance) 
테스트소프트웨어의 실시간 성능이나 전체적인 효율성
을 진단하는 테스트로, 소프트웨어의 응답 시간, 
처리량 등을 테스트
구조(Structure) 
테스트소프트웨어 내부의 논리적인 경로, 소스 코드의 
복잡도 등을 평가하는 테스트
회귀
(Regression) 
테스트소프트웨어의 변경 또는 수정된 코드에 새로운 
결함이 없음을 확인하는 테스트
병행(Parallel) 
테스트변경된 소프트웨어와 기존 소프트웨어에 동일한 
데이터를 입력하여 결과를 비교하는 테스트 
 명세 기반 
테스트• 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 
케이스로 만들어 구현하고 있는지 확인하는 테스트
• 종류 : 동등 분할, 경계 값 분석 등
구조 기반 
테스트• 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스
를 작성하고 확인하는 테스트
• 종류 : 구문 기반, 결정 기반, 조건 기반 등
경험 기반 
테스트•  유사 소프트웨어나 기술 등에 대한 테스터의 경험을 
기반으로 수행하는 테스트
•  경험 기반 테스트는 사용자의 요구사항에 대한 명세
가 불충분하거나 테스트 시간에 제약이 있는 경우 수
행하면 효과적
• 종류 : 에러 추정, 체크 리스트, 탐색적 테스팅 
## 24.2, 23.7, 22.7, 22.4, 21.5, 20.621.8
프로그램 실행 여부에 따른  
테스트
2405501
123핵심
테스트 기반(Test Bases)에  
따른 테스트
2405502
124핵심
화이트박스 테스트  
(White Box Test)
2405601
127핵심
시각에 따른 테스트
2405503
125핵심목적에 따른 테스트
2405504
126핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   38PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   38 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

39
정보처리기사 필기   핵심 요 약블랙박스 테스트는 소프트웨어가 수행할 특정 기능을 알
기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스
트로, 기능 테스트라고도 한다. 
•  프로그램의 구조를 고려하지 않기 때문에 테스트 케이
스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정
한다. • 소프트웨어 인터페이스에서 실시되는 테스트이다.
•  부정확하거나 누락된 기능, 인터페이스 오류, 자료 구
조나 외부 데이터베이스 접근에 따른 오류, 행위나 성
능 오류, 초기화와 종료 오류 등을 발견하기 위해 사용
되며, 테스트 과정의 후반부에 적용된다.기초 경로 검사
(Base Path 
Testing)• 대표적인 화이트박스 테스트 기법
•  테스트 케이스 설계자가 절차적 설계의 논리적 
복잡성을 측정할 수 있게 해주는 테스트 기법
으로, 테스트 측정 결과는 실행 경로의 기초를 
정의하는 데 지침으로 사용됨
제어 구조 검사
(Control 
Structure 
Testing)•  조건 검사(Condition Testing)  : 프로그램 모듈 
내에 있는 논리적 조건을 테스트하는 테스트 
케이스 설계 기법
•  루프 검사(Loop Testing)  : 프로그램의 반복
(Loop) 구조에 초점을 맞춰 실시하는 테스트 케
이스 설계 기법
•  데이터 흐름 검사(Data Flow Testing)  : 프로그
램에서 변수의 정의와 변수 사용의 위치에 초
점을 맞춰 실시하는 테스트 케이스 설계 기법
애플리케이션 테스트는 소프트웨어의 개발 단계에 따라 
단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 
분류된다. 이렇게 분류된 것을 테스트 레벨이라고 한다.
•  애플리케이션 테스트와 소프트웨어 개발 단계를 연결
하여 표현한 것을 V-모델이라 한다.25.5, 25.2, 24.5, 23.7, 22.7, 21.5
## 24.7, 24.5, 24.224.2, 23.7, 21.5, 20.8, 20.6
문장 검증 기준
(Statement 
Coverage)소스 코드의 모든 구문이 한 번 이상 수행되도록 
테스트 케이스 설계
분기 검증 기준
(Branch 
Coverage)결정 검증 기준(Decision Coverage)이라고도 불
리며, 소스 코드의 모든 조건문에 대해 조건이 
True인 경우와 False인 경우가 한 번 이상 수행되
도록 테스트 케이스 설계
조건 검증 기준
(Condition 
Coverage)소스 코드의 조건문에 포함된 개별 조건식의 결
과가 True인 경우와 False인 경우가 한 번 이상 
수행되도록 테스트 케이스 설계
분기/조건 기준
(Branch/
Condition 
Coverage)분기 검증 기준과 조건 검증 기준을 모두 만족하
는 설계로, 조건문이 True인 경우와 False인 경우
에 따라 조건 검증 기준의 입력 데이터를 구분하
는 테스트 케이스 설계22.4동치 분할 검사
(Equivalence 
Partitioning 
Testing, 
동치 클래스 
분해)• 입력 자료에 초점을 맞춰 테스트 케이스(동치 
클래스)를 만들고 검사하는 방법으로 동등 분
할 기법이라고도 함
• 프로그램의 입력 조건에 타당한 입력 자료와 
타당하지 않은 입력 자료의 개수를 균등하게 
하여 테스트 케이스를 정하고, 해당 입력 자료
에 맞는 결과가 출력되는지 확인하는 기법
경계값 분석
(Boundary 
Value Analysis)• 입력 자료에만 치중한 동치 분할 기법을 보완
하기 위한 기법
• 입력 조건의 중간값보다 경계값에서 오류가 발생
될 확률이 높다는 점을 이용하여 입력 조건의 경
계값을 테스트 케이스로 선정하여 검사하는 기법
원인-효과 
그래프 검사
(Cause-Effect 
Graphing 
Testing)입력 데이터 간의 관계와 출력에 영향을 미치는 
상황을 체계적으로 분석한 다음 효용성이 높은 
테스트 케이스를 선정하여 검사하는 기법
오류 예측 검사
(Error 
Guessing)• 과거의 경험이나 확인자의 감각으로 테스트하
는 기법
• 다른 블랙 박스 테스트 기법으로는 찾아낼 수 
없는 오류를 찾아내는 일련의 보충적 검사 기
법이며, 데이터 확인 검사라고도 함
비교 검사
(Comparison 
Testing)여러 버전의 프로그램에 동일한 테스트 자료를 
제공하여 동일한 결과가 출력되는지 테스트하는 
기법25.8, 25.5, 25.2, 24.7, 24.5, 23.5, 21.5, 21.3, 20.9, 20.8, 20.6
블랙박스 테스트  
(Black Box Test)
2405604
130핵심개발 단계에 따른  
애플리케이션 테스트
2405701
132핵심화이트박스 테스트의 종류
2405602
128핵심
화이트박스 테스트의 검증 기준
2405603
129핵심블랙박스 테스트의 종류
2405605
131핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   39PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   39 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

41
정보처리기사 필기   핵심 요 약•  주요 제어 모듈을 기준으로 하여 아래 단계로 이동하면
서 통합하는데, 이때 깊이 우선 통합법이나 넓이 우선 
통합법을 사용한다. 
•  테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 
있다. 
• 상위 모듈에서는 테스트 케이스를 사용하기 어렵다. 
구분 드라이버(Driver) 스텁(Stub)
개념테스트 대상의 하위 모듈을 
호출하는 도구로, 매개 변
수(Parameter)를 전달하고, 
모듈 테스트 수행 후의 결
과를 도출함제어 모듈이 호출하는 타 
모듈의 기능을 단순히 수
행하는 도구로, 일시적으로 
필요한 조건만을 가지고 있
는 시험용 모듈임
필요 
시기상위 모듈 없이 하위 모듈이 
있는 경우 하위 모듈 구동상위 모듈은 있지만 하위 
모듈이 없는 경우 하위 모
듈 대체
테스트 
방식상향식(Bottom Up) 테스트 하향식(Top-Down) 테스트
공통점 소프트웨어 개발과 테스트를 병행할 경우 이용
차이점• 이미 존재하는 하위 모듈
과 존재하지 않는 상위 
모듈 간의 인터페이스 역
할을 함
• 소프트웨어 개발이 완료
되면 드라이버는 본래의 
모듈로 교체됨•  일시적으로 필요한 조건
만을 가지고 임시로 제공
되는 가짜 모듈의 역할을 
함
•  시험용 모듈이기 때문에 
일반적으로 드라이버보다 
작성하기 쉬움회귀 테스트는 이미 테스트된 프로그램의 테스팅을 반복
하는 것으로, 통합 테스트로 인해 변경된 모듈이나 컴포
넌트에 새로운 오류가 있는지 확인하는 테스트이다.
•  회귀 테스트는 수정한 모듈이나 컴포넌트가 다른 부분
에 영향을 미치는지, 오류가 생기지 않았는지 테스트하
여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 
테스트한다.
•  회귀 테스트는 모든 테스트 케이스를 이용해 테스팅하
는 것이 가장 좋지만 시간과 비용이 많이 필요하므로 
기존 테스트 케이스 중 변경된 부분을 테스트할 수 있
는 테스트 케이스만을 선정하여 수행한다.
 애플리케이션 테스트 프로세스는 개발된 소프트웨어가 사
용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스
트하는 절차이다. 
• 순서 
테스트 계획프로젝트 계획서, 요구 명세서 등을 기반으로 
테스트 목표를 정의하고 테스트 대상 및 범위를 
결정함
테스트 분석 및 
디자인테스트의 목적과 원칙을 검토하고 사용자의 요
구 사항을 분석함
테스트 케이스 및 
시나리오 작성테스트 케이스의 설계 기법에 따라 테스트 케이
스를 작성하고 검토 및 확인한 후 테스트 시나
리오를 작성함
테스트 수행•테스트 환경을 구축한 후 테스트를 수행함
•테스트의 실행 결과를 측정하여 기록함
테스트 결과 평가 
및 리포팅테스트 결과를 비교 분석하여 테스트 결과서를 
작성함
결함 추적 및 
관리테스트를 수행한 후 결함이 어디에서 발생했는
지, 어떤 종류의 결함인지 등 결함을 추적하고 
관리함상향식 통합 테스트는 프로그램의 하위 모듈에서 상위 모
듈 방향으로 통합하면서 테스트하는 기법이다.
•  가장 하위 단계의 모듈부터 통합 및 테스트가 수행되
므로 스텁(Stub)은 필요하지 않지만, 하나의 주요 제어 
모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster)
가 필요하다. 22.4
## 25.8, 25.5, 24.5, 24.2, 22.7, 21.8, 21.3, 20.6 
 상향식 통합 테스트
(Bottom Up Integration Test)
2405803
138핵심
테스트 드라이버와  
테스트 스텁의 차이점
2405831
139핵심회귀 테스팅
(Regression Testing)
2405805
140핵심
애플리케이션 테스트 프로세스
2405901
141핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   41PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   41 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

42
정보처리기사 필기   핵심 요 약
 테스트 케이스는 구현된 소프트웨어가 사용자의 요구사
항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 
값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 
대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당
된다.
•  테스트 케이스를 미리 설계하면 테스트 오류를 방지할 
수 있고 테스트 수행에 필요한 인력, 시간 등의 낭비를 
줄일 수 있다.
•  테스트 케이스는 테스트 목표와 방법을 설정한 후 작성
한다.
•  테스트 케이스는 시스템 설계 단계에서 작성하는 것이 
가장 이상적이다.
 테스트 오라클은 테스트 결과가 올바른지 판단하기 위해 
사전에 정의된 참 값을 대입하여 비교하는 기법 및 활동을 
말한다.
•  테스트 오라클은 결과를 판단하기 위해 테스트 케이스
에 대한 예상 결과를 계산하거나 확인한다.테스트 자동화의 개념
테스트 자동화는 사람이 반복적으로 수행하던 테스트 절
차를 스크립트 형태로 구현하는 자동화 도구를 적용함으로
써 쉽고 효율적으로 테스트를 수행할 수 있도록 한 것이다.
테스트 자동화 도구의 유형
정적 분석 도구
(Static Analysis 
Tools) 프로그램을 실행하지 않고 분석하는 도구로, 소
스 코드에 대한 코딩 표준, 코딩 스타일, 코드 
복잡도 및 남은 결함 등을 발견하기 위해 사용
된다.
테스트 케이스 
생성 도구
(Test Case 
Generation 
Tools)• 자료 흐름도 : 자료 원시 프로그램을 입력받
아 파싱한 후 자료 흐름도를 작성함
• 기능 테스트 : 주어진 기능을 구동시키는 모
든 가능한 상태를 파악하여 이에 대한 입력을 
작성함
• 입력 도메인 분석 : 원시 코드의 내부를 참조
하지 않고, 입력 변수의 도메인을 분석하여 
테스트 데이터를 작성함
• 랜덤 테스트 : 입력 값을 무작위로 추출하여 
테스트함참(True) 
오라클모든 테스트 케이스의 입력 값에 대해 기대하는 결
과를 제공하는 오라클로, 발생된 모든 오류를 검출
할 수 있음
샘플링
(Sampling) 
오라클특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 
기대하는 결과를 제공하는 오라클
추정
(Heuristic) 
오라클샘플링 오라클을 개선한 오라클로, 특정 테스트 케
이스의 입력 값에 대해 기대하는 결과를 제공하고, 
나머지 입력 값들에 대해서는 추정으로 처리하는 오
라클
일관성 검사
(Consistent) 
오라클애플리케이션의 변경이 있을 때, 테스트 케이스의 
수행 전과 후의 결과 값이 동일한지를 확인하는 오
라클
 테스트 시나리오는 테스트 케이스를 적용하는 순서에 따
라 여러 개의 테스트 케이스들을 묶은 집합으로, 테스트 
케이스들을 적용하는 구체적인 절차를 명세한 문서이다.
•  테스트 시나리오에는 테스트 순서에 대한 구체적인 절
차, 사전 조건, 입력 데이터 등이 설정되어 있다.  25.5, 22.4
## 24.2, 23.2, 22.4, 20.925.2, 22.7
## 23.2, 21.8, 21.5테스트 시나리오  
(Test Scenario)
2406003
143핵심테스트 케이스(Test Case)
2406001
142핵심
테스트 오라클(Test Oracle)
2406005
144핵심테스트 오라클의 종류
2406006
145핵심
테스트 자동화 도구
2406104
146핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   42PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   42 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

46
정보처리기사 필기   핵심 요 약
XML은 특수한 목적을 갖는 마크업 언어를 만드는 데 사
용되는 다목적 마크업 언어이다.
•  웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라
우저에서 상호 호환적이지 못하다는 문제와 SGML의 
복잡함을 해결하기 위하여 개발되었다.
 인터페이스 보안 기능은 일반적으로 네트워크, 애플리케
이션, 데이터베이스 영역에 적용한다.
네트워크 
영역• 인터페이스 송·수신 간 스니핑(Sniffing) 등을 이
용한 데이터 탈취 및 변조 위협을 방지하기 위해 
네트워크 트래픽에 대한 암호화를 설정함
• 암호화는 인터페이스 아키텍처에 따라 IPSec, 
SSL, S-HTTP 등의 다양한 방식으로 적용함
애플리케이션 
영역소프트웨어 개발 보안 가이드를 참조하여 애플리케
이션 코드 상의 보안 취약점을 보완하는 방향으로 
애플리케이션 보안 기능을 적용함
데이터베이스 
영역데이터베이스, 스키마, 엔티티의 접근 권한과 프로
시저(Procedure), 트리거(Trigger) 등 데이터베이스 
동작 객체의 보안 취약점에 보안 기능을 적용함
※  IPsec(IP Security)  : 네트워크 계층에서 IP 패킷 단위의 
데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜
로, 암호화 수행시 양방향 암호화를 지원함•  데이터 무결성 검사 도구는 시스템 파일의 변경 유무를 
확인하고, 파일이 변경되었을 경우 이를 관리자에게 알
려주는 도구로, 인터페이스 보안 취약점을 분석하는데 
사용된다.
•  크래커나 허가받지 않은 내부 사용자들이 시스템에 침
입하면 백도어를 만들어 놓거나 시스템 파일을 변경하
여 자신의 흔적을 감추는데, 무결성 검사 도구를 이용
하여 이를 감지할 수 있다.
•  해시(Hash) 함수를 이용하여 현재 파일 및 디렉토리의 
상태를 DB에 저장한 후 감시하다가 현재 상태와 DB의 
상태가 달라지면 관리자에게 변경 사실을 알려준다.
•  대표적인 데이터 무결성 검사 도구에는 Tripwire, 
AIDE, Samhain, Claymore, Slipwire, Fcheck 등이 
있다.
•  인터페이스 구현을 검증하기 위해서는 인터페이스 단
위 기능과 시나리오 등을 기반으로 하는 통합 테스트가 
필요하다. 
•  통합 테스트는 다음과 같은 테스트 자동화 도구를 이용
하면 효율적으로 수행할 수 있다.
도구 기능
xUnit• 같은 테스트 코드를 여러 번 작성하지 않게 도와주
고, 테스트마다 예상 결과를 기억할 필요가 없게 하
는 자동화된 해법을 제공하는 단위 테스트 프레임워
크
• Smalltalk에 처음 적용되어 SUnit이라는 이름이었으나 
Java용의 JUnit, C++용의 CppUnit, .NET용의 NUnit, 
Http용의 HttpUnit 등 다양한 언어에 적용되면서 xUnit
으로 통칭되고 있음
STAF• 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 
지원하는 테스트 프레임워크
• 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성
할 수 있도록 지원함
• 분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬
이 프로그램 테스트에 대한 응답을 대신하며, 테스트
가 완료되면 이를 통합하고 자동화하여 프로그램을 
완성함 
## 25.8, 24.7, 24.2, 22.7, 21.5, 20.9, 20.8, 20.6AJAX는 자바 스크립트(JavaScript) 등을 이용하여 클라
이언트와 서버 간에 XML 데이터를 교환 및 제어함으로써 
이용자가 웹 페이지와 자유롭게 상호 작용할 수 있도록 하
는 비동기 통신 기술을 의미한다.20.824.2, 21.3, 20.6
## 24.7, 24.5, 24.2, 23.7, 23.2, 22.7, 21.5, 20.9, 20.8XML(eXtensible Markup 
Language)
2459914
157핵심
AJAX(Asynchronous  
JavaScript and XML)
2459915
158핵심
인터페이스 보안 기능 적용
2407203
159핵심데이터 무결성 검사 도구
2407204
160핵심
인터페이스 구현 검증 도구
2407402
161핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   46PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   46 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

56
정보처리기사 필기   핵심 요 약
데이터베이스에서 파티션은 대용량의 테이블이나 인덱스
를 작은 논리적 단위인 파티션으로 나누는 것을 말한다.
•  대용량 DB의 경우 중요한 몇 개의 테이블에만 집중되
어 데이터가 증가되므로, 이런 테이블들을 작은 단위로 
나눠 분산시키면 성능 저하를 방지할 뿐만 아니라 데이
터 관리도 쉬워진다.
파티션의 종류
범위 분할
(Range 
Partitioning) 지정한 열의 값을 기준으로 범위를 지정하여 분할
함
 일별, 월별, 분기별 등
해시 분할
(Hash 
Partitioning)• 해시 함수를 적용한 결과 값에 따라 데이터를 분할
함
• 특정 파티션에 데이터가 집중되는 범위 분할의 
단점을 보완한 것으로, 데이터를 고르게 분산할 
때 유용 함
•특정 데이터가 어디에 있는지 판단할 수 없음
• 고객번호, 주민번호 등과 같이 데이터가 고른 컬
럼에 효과적임
조합 분할
(Composite 
Partitioning)• 범위 분할로 분할한 다음 해시 함수를 적용하여 
다시 분할하는 방식
• 범위 분할한 파티션이 너무 커서 관리가 어려울 
때 유용함
목록 분할
(List 
Partitioning)지정한 열 값에 대한 목록을 만들어 이를 기준으로 
분할함
  ‘국가’라는 열에 ‘한국’, ‘미국’, ‘일본’이 있는 경우 
‘미국’을 제외할 목적으로 ‘아시아’라는 목록을 만
들어 분할함
라운드 로빈 
분할
(Round Robin 
Partitioning)•레코드를 균일하게 분배하는 방식
• 각 레코드가 순차적으로 분배되며, 기본키가 필요
없음
분산 데이터베이스는 논리적으로는 하나의 시스템에 속하
지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨
터 사이트(Site)에 분산되어 있는 데이터베이스를 말한다. • 분산 데이터베이스의 구성 요소
분산 처리기자체적으로 처리 능력을 가지며, 지리적으로 분산
되어 있는 컴퓨터 시스템
분산  
데이터베이스지리적으로 분산되어 있는 데이터베이스로서 해당 
지역의 특성에 맞게 데이터베이스가 구성됨
통신 네트워크분산 처리기들을 통신망으로 연결하여 논리적으로 
하나의 시스템처럼 작동할 수 있도록 하는 통신 네
트워크
장점•지역 자치성이 높음
•자료의 공유성이 향상됨
•분산 제어가 가능함
•시스템 성능이 향상됨
• 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
•효용성과 융통성이 높음
•신뢰성 및 가용성이 높음
•점진적 시스템 용량 확장이 용이함
단점•DBMS가 수행할 기능이 복잡함
•데이터베이스 설계가 어려움
•소프트웨어 개발 비용이 증가함
•처리 비용이 증가함
•잠재적 오류가 증가함25.8, 22.4, 22.325.8, 25.2, 24.7, 24.5, 24.2, 23.2, 22.7, 21.5, 20.8
•  위치 투명성(Location Transparency)  : 액세스하려는 데이
터베이스의 실제 위치를 알 필요 없이 단지 데이터베이
스의 논리적인 명칭만으로 액세스할 수 있음
•  중복 투명성(Replication Transparency)  : 동일 데이터가 여
러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이
터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여
러 자료에 대한 작업을 수행함
•  병행 투명성(Concurrency Transparency)  : 분산 데이터베
이스와 관련된 다수의 트랜잭션들이 동시에 실현되더
라도 그 트랜잭션의 결과는 영향을 받지 않음
•  장애 투명성(Failure Transparency)  : 트랜잭션, DBMS, 네
트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하
게 처리함25.8, 25.5, 25.2, 24.7, 23.5, 22.7, 22.3, 20.8, 20.6
## 23.7, 22.7
분산 데이터베이스 정의 및  
구성 요소
2459926
195핵심파티션(Patition)
2459925
194핵심
분산 데이터베이스의 목표
2409904
196핵심
분산 데이터베이스의 장·단점
2409905
197핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   56PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   56 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

99
정보처리기사 필기   핵심 요 약구조적 방법론은 정형화된 분석 절차에 따라 사용자 요구
사항을 파악하여 문서화하는 처리(Precess) 중심의 방법
론이다.
•  1960년대까지 가장 많이 적용되었던 소프트웨어 개발 
방법론이다.
•  쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 
것이 목적이다.
•  복잡한 문제를 다루기 위해 분할과 정복(Divide and 
Conquer) 원리를 적용한다.
컴포넌트 기반(CBD; Component Based Design) 방법론은 
기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조
합하여 하나의 새로운 애플리케이션을 만드는 방법론이다.
•  컴포넌트의 재사용(Reusability)이 가능하여 시간과 노
력을 절감할 수 있다.
•  새로운 기능을 추가하는 것이 간단하여 확장성이 보장
된다.
•  유지 보수 비용을 최소화하고 생산성 및 품질을 향상시
킬 수 있다.
• 컴포넌트 기반 방법론의 절차
개발 
준비
단계분석
단계설계
단계구현
단계테스트
단계전개
단계인도
단계소프트웨어 재사용(Software Reuse)은 이미 개발되어 인
정받은 소프트웨어의 전체 혹은 일부분을 다른 소프트웨
어 개발이나 유지에 사용하는 것이다.
•  소프트웨어 개발의 품질과 생산성을 높이기 위한 방법
으로, 기존에 개발된 소프트웨어와 경험, 지식 등을 새
로운 소프트웨어에 적용한다.
• 재사용의 이점
 - 개발 시간과 비용을 단축시킨다. 
 - 소프트웨어 품질을 향상시킨다. 
 - 소프트웨어 개발의 생산성을 향상시킨다. 
 - 프로젝트 실패의 위험을 감소시킨다. 
 - 시스템 구축 방법에 대한 지식을 공유하게 된다. 
 - 시스템 명세, 설계, 코드 등 문서를 공유하게 된다. 
소프트웨어 재공학(Software Reengineering)은 새로운 
요구에 맞도록 기존 시스템 을 이용하여 보다 나은 시스
템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능 
을 향상시키는 것이다. 
•  유지보수 비용이 소프트웨어 개발 비용의 대부분을 차
지하는 문제를 염두에 두어 기존 소프트웨어의 데이터
와 기능들의 개조 및 개선을 통해 유지보수성과 품질을 
향상 시키려는 기술이다.  21.3
정보공학 방법론은 정보 시스템의 개발을 위해 계획, 분
석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통
합 및 적용하는 자료(Data) 중심의 방법론이다.
•  정보 시스템 개발 주기를 이용하여 대규모 정보 시스템
을 구축하는데 적합하다.23.5, 22.4
## 21.5, 21.3, 20.925.8, 23.5, 22.3
소프트웨어 재사용 방법에는 합성 중심 방법과 생성 중심 
방법이 있다.
합성 중심
(Composition-
Based)전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)
을 만들어서 끼워 맞추어 소프트웨어를 완성시키
는 방법으로, 블록 구성 방법이라고도 함
생성 중심
(Generation-
Based)추상화 형태로 쓰여진 명세를 구체화하여 프로그
램을 만드는 방법으로, 패턴 구성 방법이라고도 
함20.8
## 25.2, 23.7, 22.7, 22.3, 20.8정보시스템 구축 관리 5과목
구조적 방법론
2416602
315핵심소프트웨어 재사용의 개요
2416701
318핵심
정보공학 방법론
2416603
316핵심
소프트웨어 재사용 방법
2416702
319핵심
컴포넌트 기반 방법론
2416605
317핵심
소프트웨어 재공학의 개요
2416703
320핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   99PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   99 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

100
정보처리기사 필기   핵심 요 약
•  유지보수 생산성 향상을 통해 소프트웨어 위기를 해결
하는 방법이다. 
•  기존 소프트웨어의 기능을 개조하거나 개선하므로, 예
방(Preventive) 유지보수 측면에서 소프트웨어 위기를 
해결하는 방법이라고 할 수 있다. 
•  소프트웨어 재공학도 자동화된 도구를 사용하여 소프
트웨어를 분석하고 수정하는 과정을 포함한다. 
•  소프트웨어의 수명이 연장되고, 소프트웨어 기술이 향
상될 뿐만 아니라 소프트웨어의 개발 기간도 단축된다. 
•  소프트웨어에서 발생할 수 있는 오류가 줄어들고, 비용
이 절감된다. 
• 주요 활동
분석
(Analysis)기존 소프트웨어의 명세서를 확인하여 소프트웨
어의 동작을 이해하고, 재공학할 대상을 선정하
는 활동
재구성
(Restructuring)• 기존 소프트웨어의 구조를 향상시키기 위하여 
코드를 재구성하는 활동
• 소프트웨어의 기능과 외적인 동작은 바뀌지  
않음
역공학
(Reverse 
Engineering)• 기존 소프트웨어를 분석하여 소프트웨어 개발 
과정과 데이터 처리 과정을 설명하는 분석 및 
설계 정보를 재발견하거나 다시 만들어 내는 
활동
• 일반적인 개발 단계와는 반대 방향으로 기존 
코드를 복구하거나, 기존 소프트웨어의 구성 
요소와 그 관계를 파악하여 설계도를 추출함
이식(Migration)기존 소프트웨어를 다른 운영체제나 하드웨어 환
경에서 사용할 수 있도록 변환하는 활동•  소프트웨어 개발 도구와 방법론이 결합된 것으로, 정형
화된 구조 및 방법(메커니즘)을 소프트웨어 개발에 적
용하여 생산성 향상을 구현하는 공학 기법이다.
•  소프트웨어 개발의 모든 단계에 걸쳐 일관된 방법론을 
제공하는 자동화 도구들을 지원하고, 개발자들은 이 도
구를 사용하여 소프트웨어 개발의 표준화를 지향하며, 
자동화의 이점을 얻을 수 있게 해준다.
•  CASE의 주요 기능  : 소프트웨어 생명 주기 전 단계의 연
결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등
CASE(Computer Aided Software Engineering)는 소프
트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 
검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소
프트웨어 도구를 사용하여 자동화하는 것이다.
•  객제지향 시스템, 구조적 시스템 등 다양한 시스템에서 
활용되는 자동화 도구(CASE Tool)이다.
•  소프트웨어, 하드웨어, 데이터베이스, 테스트 등을 통
합하여 소프트웨어를 개발하는 환경을 조성한다.
•  소프트웨어 생명 주기의 전체 단계를 연결해 주고 자동
화해 주는 통합된 도구를 제공해 주는 기술이다. LOC 기법은 소프트웨어 각 기능의 원시 코드 라인 수의 
비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이
를 이용하여 비용을 산정하는 기법이다.
• 측정이 용이하고 이해하기 쉬워 가장 많이 사용된다.
•  예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용
을 산정한다.
예측치  = a+4m+b단, a : 낙관치 , b : 비관치 , m : 기대치 (중간치 )
6
• 산정 공식
 - 노력(인월) = 개발 기간 × 투입 인원
= LOC / 1인당 월평균 생산 코드 라인 수
 -  개발 비용 = 노력(인월) × 단위 비용(1인당 월평균 
인건비)
 - 개발 기간 = 노력(인월) / 투입 인원
 - 생산성 = LOC / 노력(인월)24.7, 24.5, 24.2, 23.2, 22.7, 22.4, 22.3, 21.8, 21.3, 20.6
## 25.5, 25.2, 23.7, 23.5, 21.5, 21.3, 20.9, 20.8, 20.6LOC(원시 코드 라인 수,  
source Line Of Code) 기법
2417002
322핵심
CASE의 개요
2416704
321핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   100PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   100 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

101
정보처리기사 필기   핵심 요 약수학적 산정 기법은 상향식 비용 산정 기법으로, 경험적 
추정 모형, 실험적 추정 모형 이라고도 하며, 개발 비용 
산정의 자동화를 목표로 한다.
•  비용을 자동으로 산정하기 위해 사용되는 공식은 과거 
유사한 프로젝트를 기반으로하여 경험적으로 유도된 
것이다.
•  수학적 산정 기법에는 COCOMO 모형, Putnam 모형, 
기능 점수(FP) 모형 등이 있으며 각 모형에서는 지정된 
공식을 사용하여 비용을 산정한다.반분리형
(Semi-
Detached 
Mode)• 조직형과 내장형의 중간형으로 트랜잭션 처리 시
스템이나 운영체제, 데이터베이스 관리 시스템 등
의 30만(300KDSI) 라인 이하의 소프트웨어를 개발
하는 유형
• 컴파일러, 인터프리터와 같은 유틸리티 개발에 적
합함
내장형
(Embedded 
Mode)• 초대형 규모의 트랜잭션 처리 시스템이나 운영체
제 등의 30만(300KDSI)라인 이상의 소프트웨어를 
개발하는 유형
• 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처
리 시스템 등의 시스템 프로그램 개발에 적합함
조직형
(Organic 
Mode)• 기관 내부에서 개발된 중·소 규모의 소프트웨어
로 일괄 자료 처리나 과학 기술 계산용, 비즈니스 
자료 처리용으로 5만(50KDSI) 라인 이하의 소프트
웨어를 개발하는 유형
• 사무 처리용, 업무용, 과학용 응용 소프트웨어 개
발에 적합함기능 점수(Function Point) 모형은 알브레히트(Albrecht)
가 제안한 것으로, 소프트웨어의 기능을 증대시키는 요
인별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 
기능 점수를 산출하며 총 기능 점수와 영향도를 이용하여 
기능 점수(FP)를 구한 후 이를 이용해서 비용을 산정하는 
기법이다.
• 소프트웨어 기능 증대 요인
 - 자료 입력(입력 양식)
 - 정보 출력(출력 보고서)
 - 명령어(사용자 질의수)
 - 데이터 파일
 - 필요한 외부 루틴과의 인터페이스 25.5, 24.7, 23.5, 22.7, 21.8, 21.5, 21.3, 20.8, 20.621.5, 20.9
COCOMO(COnstructive COst MOdel) 모형은 보헴
(Boehm)이 제안한 것으로, 원시 프로그램의 규모인 
LOC(원시 코드 라인 수)에 의한 비용 산정 기법이다.
•  개발할 소프트웨어의 규모(LOC)를 예측한 후 이를 소
프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정
식에 대입하여 비용을 산정한다.
•  비교적 작은 규모의 프로젝트들을 통계 분석한 결과를 
반영한 모델이므로 중소 규모 소프트웨어 프로젝트 비
용 추정에 적합하다.
•  같은 규모의 프로그램이라도 그 성격에 따라 비용이 다
르게 산정된다.
•  비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력
(Man-Month)으로 나타난다.25.2, 22.7, 22.4 Putnam 모형은 소프트웨어 생명 주기의 전 과정 동안에 
사용될 노력의 분포를 가정해 주는 모형이다.
•  푸트남(Putnam)이 제안한 것으로 생명 주기 예측 모형
이라고도 한다.
•  시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선
의 노력 분포도를 기초로 한다.
• 대형 프로젝트의 노력 분포 산정에 이용되는 기법이다.
•  개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 
감소한다.20.6
## 20.8
COCOMO의  
소프트웨어 개발 유형
2417103
325핵심수학적 산정 기법의 개요
2417101
323핵심
Putnam 모형
2417104
326핵심
COCOMO 모형 개요
2417102
324핵심
기능 점수(FP) 모형
2417105
327핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   101PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   101 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

103
정보처리기사 필기   핵심 요 약프로젝트 관리는 주어진 기간 내에 최소의 비용으로 사용
자를 만족시키는 시스템을 개발하기 위한 전반적인 활동
이다. 
관리 유형 주요 내용
일정 관리 작업 순서, 작업 기간 산정, 일정 개발, 일정 통제
비용 관리 비용 산정, 비용 예산 편성, 비용 통제
인력 관리프로젝트 팀 편성, 자원 산정, 프로젝트 조직 정의, 프
로젝트 팀 개발, 자원 통제, 프로젝트 팀 관리
위험 관리 위험 식별, 위험 평가, 위험 대처, 위험 통제
품질 관리 품질 계획, 품질 보증 수행, 품질 통제 수행
CMMI(능력 성숙도 통합 모델)는 소프트웨어 개발 조직의 
업무 능력 및 조직의 성숙도를 평가하는 모델로, 미국 카
네기멜론 대학교의 소프트웨어 공학연구소(SEI)에서 개발
하였다. SPICE(소프트웨어 처리 개선 및 능력 평가 기준)는 정보 
시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위
해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준으
로, 공식 명칭은 ISO/IEC 15504이다.
•  SPICE는 5개의 프로세스 범주와 40개의 세부 프로세
스로 구성된다.
•  SPICE는 프로세스 수행 능력 단계를 불완전, 수행, 관
리, 확립, 예측, 최적화의 6단계로 구분한다.
단계 특징
불완전
(Incomplete)프로세스가 구현되지 않았거나 목적을 달성하지 못
한 단계
수행
(Performed)프로세스가 수행되고 목적이 달성된 단계
관리
(Managed)정의된 자원의 한도 내에서 그 프로세스가 작업 산
출물을 인도하는 단계
확립
(Established)소프트웨어 공학 원칙에 기반하여 정의된 프로세스
가 수행되는 단계
예측
(Predictable)프로세스가 목적 달성을 위해 통제되고, 양적인 측
정을 통해서 일관되게 수행되는 단계
최적화
(Optimizing)프로세스 수행을 최적화하고, 지속적인 개선을 통
해 업무 목적을 만족시키는 단계•  CMMI의 소프트웨어 프로세스 성숙도는 초기, 관리, 
정의, 정량적 관리, 최적화의 5단계로 구분한다.
단계 프로세스 특징
초기
(Initial)정의된 프로세스 
없음작업자 능력에 따라 성공 여
부 결정
관리
(Managed)규칙화된 프로세스특정한 프로젝트 내의 프로
세스 정의 및 수행
정의
(Defined)표준화된 프로세스조직의 표준 프로세스를 활
용하여 업무 수행
정량적 관리
(Quantitatively 
Managed)예측 가능한 프로
세스프로젝트를 정량적으로 관
리 및 통제
최적화
(Optimizing)지속적 개선 프로
세스프로세스 역량 향상을 위해 
지속적인 프로세스 개선
## 25.2, 24.5, 23.2, 20.9, 20.625.2, 24.5, 23.5, 23.2, 22.4, 22.3
## 21.5, 20.9, 20.8
ISO/IEC 12207은 ISO(International Organization for 
Standardization, 국제표준화기구)에서 만든 표준 소프트
웨어 생명 주기 프로세스로, 소프트웨어의 개발, 운영, 유
지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 
주기 표준을 제공한다.
•  ISO/IEC 12207은 기본 생명 주기 프로세스, 지원 생명 
주기 프로세스, 조직 생명 주기 프로세스로 구분한다.
기본 생명 주기 
프로세스획득, 공급, 개발, 운영, 유지보수 프로세스
지원 생명 주기 
프로세스 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 
형상 관리, 문제 해결 프로세스
조직 생명 주기 
프로세스 관리, 기반 구조, 훈련, 개선 프로세스21.5프로젝트 관리  
(Project Management)
2417331
331핵심
CMMI(Capability Maturity  
Model Integration)
2417403
333핵심SPICE(Software Process Improvement  
and Capability dEtermination)
2417404
334핵심ISO/IEC 12207
2417402
332핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   103PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   103 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

104
정보처리기사 필기   핵심 요 약
프레임워크(Framework)는 소프트웨어 개발에 공통적으
로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 
구현할 수 있도록 여러 가지 기능들을 제공해주는 반제품 
형태의 소프트웨어 시스템이다.
•  선행 사업자의 기술에 의존하지 않은 표준화된 개발 기
반으로 인해 사업자 종속성이 해소된다.
•  프레임워크의 주요 기능에는 예외 처리, 트랜잭션 처
리, 메모리 공유, 데이터 소스 관리, 서비스 관리, 쿼리 
서비스, 로깅 서비스, 사용자 인증 서비스 등이 있다.
• 프레임워크의 종류
스프링 프레임워크
(Spring Framework)자바 플랫폼을 위한 오픈 소스 경량형 애플
리케이션 프레임워크
전자정부 프레임워크우리나라의  공공부문  정보화 사업 시 효율
적인 정보 시스템의  구축을 지원하기  위해 
필요한 기능 및 아키텍처를  제공하는  프레
임워크
닷넷 프레임워크
(.NET Framework)Windows 프로그램의  개발 및 실행 환경을 
제공하는  프레임워크로 , Microsoft 사에서 
통합 인터넷 전략을 위해 개발함소프트웨어 개발 방법론 테일러링은 프로젝트 상황 및 특
성에 맞도록 정의된 소프트웨어 개발 방법론의 절차, 사
용기법 등을 수정 및 보완하는 작업이다.
•  소프트웨어 개발 방법론 테일러링 작업 시 고려해야 할 
사항에는 내부적 기준과 외부적 기준이 있다.
내부적 
기준• 목표 환경 : 시스템의 개발 환경과 유형이 서로 다른 경
우 테일러링이 필요함
• 요구사항 : 프로젝트의 생명 주기 활동에서 개발, 운영, 
유지보수 등 프로젝트에서 우선적으로 고려할 요구사
항이 서로 다른 경우 테일러링이 필요함
• 프로젝트 규모 : 비용, 인력, 기간 등 프로젝트의 규모가 
서로 다른 경우 테일러링이 필요함
• 보유 기술 : 프로세스, 개발 방법론, 산출물, 구성원의 능
력 등이 서로 다른 경우 테일러링이 필요함
외부적 
기준• 법적 제약사항 : 프로젝트별로 적용될 IT Compliance가 
서로 다른 경우 테일러링이 필요함
• 표준 품질 기준 : 금융, 제도 등 분야별 표준 품질 기준
이 서로 다른 경우 테일러링이 필요함모듈화
(Modularity)프레임워크는 캡슐화를 통해 모듈화를 강화하고 
설계 및 구현의 변경에 따른 영향을 최소화함으로
써 소프트웨어의 품질을 향상시킴
프레임워크는 개발표준에 의한 모듈화로 인해 유
지 보수가 용이함
재사용성
(Reusability)프레임워크는 재사용 가능한 모듈들을 제공함으
로써 예산 절감, 생산성 향상, 품질 보증이 가능함
확장성
(Extensibility)프레임워크는 다형성(Polymorphism)을 통한 인터
페이스 확장이 가능하여 다양한 형태와 기능을 가
진 애플리케이션 개발이 가능함
제어의 역흐름
(Inversion of 
Control)개발자가 관리하고 통제해야 하는 객체들의 제어를 
프레임워크에 넘김으로써 생산성을 향상시킴
소프트웨어 정의 기술은 네트워크, 데이터 센터 등에서 
소유한 자원을 가상화하여 개별 사용자에게 제공하고, 중
앙에서는 통합적으로 제어가 가능한 기술이다.
• 관련 용어
용어 의미
소프트웨어 정의 
네트워킹
(SDN; Software 
Defined 
Networking, )• 네트워크를 컴퓨터처럼 모델링하여 여러 사
용자가 각각의 소프트웨어들로 네트워킹을 
가상화하여 제어하고 관리하는 네트워크
•  하드웨어에 의존하는 네트워크 체계에 비해 
보다 효율적으로 네트워크를 제어, 관리할 수 
있음
•  기존 네트워크에는 영향을 주지 않으면서 특
정 서비스의 전송 경로 수정을 통하여 인터넷
상에서 발생하는 문제를 처리할 수 있음
소프트웨어 정
의 데이터 센터
(SDDC; Software 
Defined Data 
Center)데이터 센터의 모든 자원을 가상화하여 인력의 
개입없이 소프트웨어 조작만으로 관리 및 제어
되는 데이터 센터
소프트웨어 정의 
스토리지
(SDS; Software-
Defined Storage)물리적인 데이터 스토리지(Data Storage)를 가
상화하여 여러 스토리지를 하나처럼 관리하거
나, 하나의 스토리지를 여러 스토리지로 나눠 
사용할 수 있는 기술22.3, 20.6
## 23.7, 22.4, 21.8, 21.5, 20.922.4, 21.8, 20.9, 20.6
## 24.2, 23.2, 22.4, 21.8소프트웨어 개발 방법론  
테일러링
2459942
335핵심
소프트웨어 정의 기술(SDE, SDx; 
Software-Defined Everything)
2417702
338핵심
소프트웨어 개발 프레임워크
2417601
336핵심프레임워크의 특성
2417631
337핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   104PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   104 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

105
정보처리기사 필기   핵심 요 약메타버스
(Metaverse)• 가공(Meta)과 현실 세계(Universe)의 합성어
로, 현실 세계와 같은 사회·경제·문화 활
동이 이뤄지는 3차원 가상 세계를 가리킴
• 1992년 미국 SF 작가 닐 스티븐슨의 소설 
‘스노 크래시’에 처음 등장하였음
성형
(Star, 중앙 집중형) • 중앙에 중앙 컴퓨터가 있고, 이를 중심으로 
단말장치들이 연결되는 중앙 집중식의 네
트워크 구성 형태
• 포인트 투 포인트(Point-to-Point) 방식으로 
회선을 연결함
링형
(Ring, 루프형)• 컴퓨터와 단말장치들을 서로 이웃하는 것
끼리 포인트 투 포인트(Point-to-Point) 방
식으로 연결시킨 형태
•분산 및 집중 제어 모두 가능함
• 데이터는 단방향 또는 양방향으로 전송할 
수 있으며, 단방향 링의 경우 컴퓨터, 단말
장치, 통신 회선 중 어느 하나라도 고장나
면 전체 통신망에 영향을 미침
버스형
(Bus)• 한 개의 통신 회선에 여러 대의 단말장치가 
연결되어 있는 형태
• 물리적 구조가 간단하고, 단말장치의 추가
와 제거가 용이함
• 단말장치가 고장나더라도 통신망 전체에 
영향을 주지 않기 때문에 신뢰성을 높일 수 
있음
계층형
(Tree, 분산형)중앙 컴퓨터와 일정 지역의 단말장치까지는 
하나의 통신 회선으로 연결시키고, 이웃하는 
단말장치는 일정 지역 내에 설치된 중간 단말
장치로부터 다시 연결시키는 형태
망형
(Mesh)• 모든 지점의 컴퓨터와 단말장치를 서로 연
결한 형태로, 노드의 연결성이 높음
• 많은 단말장치로부터 많은 양의 통신을 필
요로 하는 경우에 유리함
• 보통 공중 데이터 통신망에서 사용되며, 통
신 회선의 총 경로가 가장 김
• 모든 노드를 망형으로 연결하려면 노드의 
수가 n개일 때, n(n-1)/2개의 회선이 필요하
고 노드당 n-1개의 포트가 필요함IoT(Internet of 
Things, 
사물 인터넷)정보 통신 기술을 기반으로 실세계(Physical 
World)와 가상 세계(Virtual World)의 다양한 사
물들을 인터넷으로 서로 연결하여 진보된 서
비스를 제공하기 위한 서비스 기반 기술
메시 네트워크
(Mesh Network)차세대 이동통신, 홈네트워킹, 공공 안전 등 
특수 목적을 위한 새로운 방식의 네트워크 
기술로, 대규모 디바이스의 네트워크 생성에 
최적화되어 있음
피코넷
(PICONET)여러 개의 독립된 통신장치가 블루투스 기술
이나 UWB 통신 기술을 사용하여 통신망을 
형성하는 무선 네트워크 기술
파장 분할 다중화
(WDM, 
Wavelength 
Division 
Multiplexing)광섬유를 이용한 통신 기술의 하나로, 파장
이 서로 다른 복수의 신호를 보냄으로써 여
러 대의 단말기가 동시에 통신 회선을 사용
할 수 있도록 하는 것
유비쿼터스 컴
퓨팅(Ubiquitous 
Computing)• 언제 어디서나 어떤 기기를 통해서도 컴퓨팅
이 가능한 환경을 의미하는 포괄적인 개념
• 모든 사물에 초소형 칩을 내장시켜 네트워
크로 연결하고, 사물 간에 통신이 가능한 
사물 인터넷(IoT) 기술이 이 개념을 실현하
는 핵심 수단 중 하나임
클라우드 기반 HSM
(Cloud-based 
Hardware
Security Module)• 클라우드를 기반으로 암호화 키의 생성·
저장·처리 등의 작업을 수행하는 보안기
기를 가리키는 용어
• 클라우드에 인증서를 저장하므로 스마트
폰과 같은 개별 기기에 인증서를 저장할 
필요가 없음
파스-타(PaaS-TA) • 소프트웨어 개발 환경을 제공하기 위해 개
발한 개방형 클라우드 컴퓨팅 플랫폼
• 국내 IT 서비스 경쟁력 강화를 목표로 과
학기술정보통신부와 한국정보 화진흥원이 
연구개발(R&D)을 지원하였으며, 인프라 제
어 및 관리 환경, 실행 환경, 개발 환경, 서
비스 환경, 운영 환경으로 구성되어 있음
징(Zing)• 10cm 이내 거리에서 3.5Gbps 속도의 데
이터 전송이 가능한 초고속 근접무선통신
(NFC)
• 휴대용 스마트 기기, 노트북, 쇼핑몰·거리 
등의 광고나 키오스크에 접목하여 사용할 
수 있음
웹 크롤링(Web 
Crawling)웹에서 자동화된 프로그램을 이용해 데이터
를 수집하는 작업
SSO
(Single Sign On)한 번의 로그인으로 개인이 가입한 모든 사
이트를 이용할 수 있게 해주는 시스템
스마트 그리드
(Smart Grid)전력선을 기반으로 모든 통신, 정보, 관련 애
플리케이션 인프라를 하나의 시스템으로 통
합하여 관리함으로써 효율적인 에너지 관리
가 가능함25.8, 25.5, 25.2, 24.7, 24.2, 23.7, 23.5, 23.2, 22.7, 22.4, 21.8
## 23.2, 21.3, 20.8네트워크 관련 신기술
2459964
339핵심
네트워크(Network) 설치 구조
2459943
340핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   105PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   105 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

110
정보처리기사 필기   핵심 요 약
※ 로킹 단위(Locking Granularity) 
•  병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 
의미한다. 
•  데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 
수 있다. 
•  로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병
행성 수준이 낮아지고, 로킹 단위가 작으면 로크 수가 
많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 
수준이 높아진다. 발견 기법
(Detection)• 시스템에 교착상태가 발생했는지 점검하여 교
착상태에 있는 프로세스와 자원을 발견하는 것
을 의미함
• 교착상태 발견 알고리즘과 자원 할당 그래프 등
을 사용할 수 있음
회복 기법
(Recovery)교착상태를 일으킨 프로세스를 종료하거나 교착
상태의 프로세스에 할당된 자원을 선점하여 프로
세스나 자원을 회복하는 것을 의미함
교착상태(Dead Lock)는 상호 배제에 의해 나타나는 문제
점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 
서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무
한정 기다리는 현상을 의미한다. 
• 교착상태 발생의 필요 충분 조건
상호 배제
(Mutual 
Exclusion) 한 번에 한 개의 프로세스만이 공유 자원을 사용
할 수 있어야 함
점유와 대기
(Hold and 
Wait) 최소한 하나의 자원을 점유하고 있으면서 다른 프
로세스에 할당되어 사용되고 있는 자원을 추가로 
점유하기 위해 대기하는 프로세스가 있어야 함
비선점
(Non-
preemption)다른 프로세스에 할당된 자원은 사용이 끝날 때까
지 강제로 빼앗을 수 없어야 함
환형 대기
(Circular Wait)공유 자원과 공유 자원을 사용하기 위해 대기하는 
프로세스들이 원형으로 구성되어 있어 자신에게 
할당된 자원을 점유하면서 앞이나 뒤에 있는 프로
세스의 자원을 요구해야 함
• 교착상태의 해결 방법
예방 기법
(Prevention)• 교착상태가 발생하지 않도록 사전에 시스템을 
제어하는 방법으로, 교착상태 발생의 네 가지 
조건 중에서 어느 하나를 제거(부정)함으로써 수
행됨
•자원의 낭비가 가장 심한 기법
회피 기법
(Avoidance)• 교착상태가 발생할 가능성을 배제하지 않고 교
착상태가 발생하면 적절히 피해나가는 방법으
로, 주로 은행원 알고리즘(Banker’s Algorithm)이 
사용됨
• 은행원 알고리즘(Banker’s Algorithm) : E. J. 
Dijkstra가 제안한 것으로, 은행에서 모든 고객의 
요구가 충족되도록 현금을 할당하는 데서 유래
한 기법Secure SDLC는 보안상 안전한 소프트웨어를 개발하기 
위해 SDLC에 보안 강화를 위한 프로세스를 포함한 것을 
의미한다.
•  Secure SDLC는 소프트웨어의 유지 보수 단계에서 보
안 이슈를 해결하기 위해 소모되는 많은 비용을 최소화
하기 위해 등장하였다.
•  Secure SDLC는 요구사항 분석, 설계, 구현, 테스트, 
유지 보수 등 SDLC 전체 단계에 걸쳐 수행되어야 할 
보안 활동을 제시한다.
• Secure SDLC의 대표적인 방법론
CLASP• Secure Software 사에서 개발하였으며, SDLC의 초
기 단계에서 보안을 강화하기 위해 개발된 방법론
• 활동 중심, 역할 기반의 프로세스로 구성되어 있으
며, 현재 운용 중인 시스템에 적용하기에 적합함
SDL• 마이크로소프트 사에서 안전한 소프트웨어 개발
을 위해 기존의 SDLC를 개선한 방법론
•전통적인 나선형 모델을 기반으로 함
Seven 
Touchpoints• 소프트웨어 보안의 모범사례를 SDLC에 통합한 
방법론
• 설계 및 개발 과정의 모든 산출물에 대해 위험 분
석 및 테스트를 수행함
• SDLC의 각 단계에 관련된 7개의 보안 강화 활동
을 수행함25.2, 24.7, 24.2, 23.2, 21.5, 21.3, 20.6
## 20.8교착상태
2459948
354핵심
Secure SDLC의 개요
2419101
355핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   110PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   110 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

111
정보처리기사 필기   핵심 요 약세션 하이재킹은 서버에 접속하고 있는 클라이언트들의 
세션 정보를 가로채는 공격 기법으로, 세션 가로채기라고
도 한다.
•  정상적인 연결을 RST(Reset) 패킷을 통해 종료시킨 후 
재연결 시 희생자가 아닌 공격자에게 연결하는 방식  
이다.
•  공격자는 서버와 상호 간의 동기화된 시퀀스 번호를 이
용하여 인가되지 않은 시스템의 기능을 이용하거나 중
요한 정보에 접근할 수 있게 된다.
•  탐지 방법에는 비동기화 상태 탐지, ACK Storm 탐
지, 패킷의 유실 탐지, 예상치 못한 접속의 리셋 탐지가  
있다.보안 요소는 소프트웨어 개발에 있어 충족시켜야할 요소 
및 요건을 의미한다.
•  보안 3대 요소에는 기밀성(Confidentiality), 무결성
(Integrity), 가용성(Availability)이 있으며, 그 외에도 
인증(Authentication), 부인 방지(NonRepudiation) 
등이 있다. 
기밀성• 시스템 내의 정보와 자원은 인가된 사용자에게만 접근
이 허용됨
•정보가 전송 중에 노출되더라도 데이터를 읽을 수 없음
무결성 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음
가용성 인가받은 사용자는 언제라도 사용할 수 있음
인증• 시스템 내의 정보와 자원을 사용하려는 사용자가 합법
적인 사용자인지를 확인하는 모든 행위를 말함
• 대표적 방법으로는 패스워드, 인증용 카드, 지문 검사 
등이 있음
부인 
방지데이터를 송·수신한 자가 송·수신 사실을 부인할 수 없도
록 송·수신 증거를 제공함SQL 삽입• 웹 응용 프로그램에 SQL을 삽입하여 내부 데이
터베이스(DB) 서버의 데이터를 유출 및 변조하
고, 관리자 인증을 우회하는 보안 약점
• 동적 쿼리에 사용되는 입력 데이터에 예약어 및 
특수문자가 입력되지 않게 필터링 되도록 설정
하여 방지할 수 있음
경로 조작 및 
자원 삽입• 데이터 입출력 경로를 조작하여 서버 자원을 수
정·삭제할 수 있는 보안 약점
• 사용자 입력값을 식별자로 사용하는 경우, 경로 
순회 공격을 막는 필터를 사용하여 방지할 수 
있음
크로스사이트 
스크립팅(XSS)• 웹페이지에 악의적인 스크립트를 삽입하여 방
문자들의 정보를 탈취하거나, 비정상적인 기능 
수행을 유발하는 보안 약점
• HTML 태그의 사용을 제한하거나 스크립트에 
삽입되지 않도록 ‘ <  ’, ‘  > ’, ‘&’ 등의 문자를 다른 
문자로 치환함으로써 방지할 수 있음
운영체제 
명령어 삽입• 외부 입력값을 통해 시스템 명령어의 실행을 유
도함으로써 권한을 탈취하거나 시스템 장애를 
유발하는 보안 약점
• 웹 인터페이스를 통해 시스템 명령어가 전달되
지 않도록 하고, 외부 입력값을 검증 없이 내부 
명령어로 사용하지 않음으로써 방지할 수 있음
위험한 형식 
파일 업로드• 악의적인 명령어가 포함된 스크립트 파일을 업
로드함으로써 시스템에 손상을 주거나, 시스템
을 제어할 수 있는 보안 약점
• 업로드 되는 파일의 확장자 제한, 파일명의 암호
화, 웹사이트와 파일 서버의 경로 분리, 실행 속
성을 제거하는 등의 방법으로 방지할 수 있음
신뢰되지 않는 
URL 주소로 
자동접속 연결• 입력 값으로 사이트 주소를 받는 경우 이를 조
작하여 방문자를 피싱 사이트로 유도하는 보안 
약점
• 연결되는 외부 사이트의 주소를 화이트 리스트
로 관리함으로써 방지할 수 있음
메모리 버퍼 
오버플로• 연속된 메모리 공간을 사용하는 프로그램에서 할
당된 메모리의 범위를 넘어선 위치에서 자료를 
읽거나 쓰려고 할 때 발생하는 보안 약점
• 프로그램의 오동작을 유발시키거나, 악의적인 
코드를 실행시켜 공격자가 프로그램을 통제할 
수 있는 권한을 획득하게 함
• 메모리 버퍼를 사용할 경우 적절한 버퍼의 크기를 
설정하고, 설정된 범위의 메모리 내에서 올바르게 
읽거나 쓸 수 있도록 함으로써 방지할 수 있음25.2, 24.7, 22.7, 21.325.2, 24.2, 23.7, 22.7, 22.3, 21.8, 20.9, 20.8 25.8, 25.5, 25.2, 24.7, 23.5, 23.2, 22.7, 22.4, 21.3, 20.8, 20.6
세션 하이재킹  
(Session Hijacking)
2459949
357핵심입력 데이터 검증 및  
표현의 보안 약점
2419302
358핵심보안 요소
2419131
356핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   111PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   111 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34