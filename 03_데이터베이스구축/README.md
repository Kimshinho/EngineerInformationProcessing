7
정보처리기사 필기   핵심 요 약요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제
공하는 서비스에 대한 설명과 정상적으로 운영되는데 필
요한 제약조건 등을 나타낸다.
요구사항의 유형 
유형 내용
기능 
요구사항
(Functional 
requirements)• 시스템이 무엇을 하는지, 어떤 기능을 하는지에 
대한 사항
• 시스템의 입력이나 출력으로 무엇이 포함되어
야 하는지, 시스템이 어떤 데이터를 저장하거나 
연산을 수행해야 하는지에 대한 사항
•시스템이 반드시 수행해야 하는 기능
• 사용자가 시스템을 통해 제공받기를 원하는 기능
비기능 
요구사항
(Non-
functional 
requirements)• 시스템 장비 구성 요구사항 : 하드웨어, 소프트
웨어, 네트워크 등의 시스템 장비 구성에 대한 
요구사항
• 성능 요구사항 : 처리 속도 및 시간, 처리량, 동적·
정적 적용량, 가용성 등 성능에 대한 요구사항
• 인터페이스 요구사항 : 시스템 인터페이스와 사
용자 인터페이스에 대한 요구사항으로 다른 소
프트웨어, 하드웨어 및 통신 인터페이스, 다른 
시스템과의 정보 교환에 사용되는 프로토콜과
의 연계도 포함하여 기술
• 데이터 요구사항 : 초기 자료 구축 및 데이터 변
환을 위한 대상, 방법, 보안이 필요한 데이터 등 
데이터를 구축하기 위해 필요한 요구사항
• 테스트 요구사항 : 도입되는 장비의 성능 테스
트(BMT)나 구축된 시스템이 제대로 운영되는지
를 테스트하고 점검하기 위한 테스트 요구사항
• 보안 요구사항 : 시스템의 데이터 및 기능, 운영 
접근을 통제하기 위한 요구사항
• 품질 요구사항 : 관리가 필요한 품질 항목, 품질 
평가 대상에 대한 요구사항으로 가용성, 정합성, 
상호 호환성, 대응성, 신뢰성, 사용성, 유지·관리
성, 이식성, 확장성, 보안성 등으로 구분하여 기술
• 제약사항 : 시스템 설계, 구축, 운영과 관련하여 
사전에 파악된 기술, 표준, 업무, 법·제도 등의 
제약조건
• 프로젝트 관리 요구사항 : 프로젝트의 원활한 
수행을 위한 관리 방법에 대한 요구사항
• 프로젝트 지원 요구사항 : 프로젝트의 원활한 수
행을 위한 지원 사항이나 방안에 대한 요구사항 웹 애플리케이션 서버는 정적인 콘텐츠 처리를 하는 웹 서
버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 
처리하기 위해 사용되는 미들웨어이다.
•  데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이
브러리를 제공한다. DBMS(DataBase Management System)는 사용자와 데
이터베이스 사이에서 사용자의 요구에 따라 정보를 생성
해 주고, 데이터베이스를 관리해 주는 소프트웨어이다.
•  DBMS는 기존의 파일 시스템이 갖는 데이터의 종속성
과 중복성의 문제를 해결하기 위해 제안된 시스템으로, 
모든 응용 프로그램들이 데이터베이스를 공용할 수 있
도록 관리해 준다.
•  DBMS는 데이터베이스의 구성, 접근 방법, 유지관리에 
대한 모든 책임을 진다.
•  DBMS의 종류에는 Oracle, IBM DB2, Microsoft SQL 
Server, MySQL, SQLite, MongoDB, Redis 등이 있다. 
• DBMS 관련 요구사항 식별 시 고려사항
 - 가용성   - 성능
 - 기술 지원   - 상호 호환성
 - 구축 비용23.2, 20.6
## 21.325.5, 24.5, 23.2, 21.8• 주로 데이터베이스 서버와 연동해서 사용한다.
•  웹 애플리케이션 서버의 종류에는 Tomcat, GlassFish, 
JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 
등이 있다.2단계아키텍처 구성 
파악최상위 수준에서 계층별로 표현한 
아키텍처 구성도를 작성함
소프트웨어 구성 
파악소프트웨어들의 제품명, 용도, 라이
선스 적용 방식, 라이선스 수 등을 
명시함
3단계하드웨어 구성 
파악단위 업무 시스템들이 운용되는 서
버의 주요 사양과 수량, 그리고 서버
의 이중화의 적용 여부를 명시함
네트워크 구성 
파악서버의 위치, 서버 간의 네트워크 연
결 방식을 네트워크 구성도로 작성함
데이터베이스 관리 시스템  
(DBMS)
2459902
013핵심
웹 애플리케이션 서버(WAS)
2400506
014핵심요구사항 정의
2459903
015핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   7PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   7 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

24
정보처리기사 필기   핵심 요 약
•  요구사항 검토(Requirements Review) : 요구사항 명세서
의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 
담당자들이 수작업으로 분석하는 방법으로, 동료검토, 
워크스루, 인스펙션 등이 있음 
동료검토
(Peer 
Review)요구사항 명세서 작성자가 명세서 내용을 직접 설명
하고 동료들이 이를 들으면서 결함을 발견하는 형태
의 검토 방법
워크스루
(Walk 
Through)검토 회의 전에 요구사항 명세서를 미리 배포하여 사
전 검토한 후에 짧은 검토 회의를 통해 결함을 발견
하는 형태의 검토 방법
인스펙션
(Inspection)요구사항 명세서 작성자를 제외한 다른 검토 전문가
들이 요구사항 명세서를 확인하면서 결함을 발견하
는 형태의 검토 방법
•  프로토타이핑(Prototyping)  : 사용자의 요구사항을 정확히 
파악하기 위해 실제 개발될 소프트웨어에 대한 견본품
(Prototype)을 만들어 최종 결과물을 예측함
•  테스트 설계  : 요구사항은 테스트할 수 있도록 작성되어
야 하며, 이를 위해 테스트 케이스(Test Case)를 생성
하여 이후에 요구사항이 현실적으로 테스트 가능한지
를 검토함
•  CASE 도구 활용  : 일관성 분석(Consistency Analysis)
을 통해 요구사항 변경사항의 추적 및 분석, 관리하고, 
표준 준수 여부를 확인함
DB Link DB에서 제공하는 DB Link 객체를 이용하는 방식
API/
Open API송신 시스템의 데이터베이스(DB)에서 데이터를 읽어 
와 제공하는 애플리케이션 프로그래밍 인터페이스 프
로그램
연계 
솔루션EAI 서버와 송·수신 시스템에 설치되는 클라이언트
(Client)를 이용하는 방식
  Socket서버는 통신을 위한 소켓(Socket)을 생성하여 포트를 
할당하고 클라이언트의 통신 요청 시 클라이언트와 연
결하여 통신하는 네트워크 기술
Web 
Service웹 서비스(Web Service)에서 WSDL과 UDDI, SOAP 프
로토콜을 이용하여 연계하는 서비스•  송신 시스템  : 연계 프로그램으로부터 생성된 데이터를 
전송 형식에 맞게 인터페이스 테이블이나 파일(xml, 
csv, text 등)로 변환한 후 송신하는 시스템
•  수신 시스템  : 수신한 인터페이스 테이블이나 파일을 연
계 프로그램에서 처리할 수 있는 형식으로 변환한 후 
연계 프로그램에 반영하는 시스템
•  연계 서버  : 송·수신 시스템 사이에 위치하여 데이터의 
송·수신 현황을 모니터링하는 역할을 수행함
 미들웨어는 미들(Middle)과 소프트웨어(Software)의 합
성어로, 운영체제와 응용 프로그램, 또는 서버와 클라
이언트 사이에서 다양한 서비스를 제공하는 소프트웨어  
이다. 
DB
(DataBase)• DB는 데이터베이스 벤더에서 제공하는 클라
이언트에서 원격의 데이터베이스와 연결하기 
위한 미들웨어
• DB를 사용하여 시스템을 구축하는 경우 보통 
2-Tier 아키텍처라고 함
RPC
(Remote 
Procedure Call)RPC(원격 프로시저 호출)는 응용 프로그램의 프
로시저를 사용하여 원격 프로시저를 마치 로컬 
프로시저처럼 호출하는 방식의 미들웨어
MOM
(Message 
Oriented 
Middleware)• MOM(메시지 지향 미들웨어)은 메시지 기반의 
비동기형 메시지를 전달하는 방식의 미들웨어
• 온라인 업무보다는 이기종 분산 데이터 시스
템의 데이터 동기를 위해 많이 사용됨
TP-Monitor
(Transaction 
Processing 
Monitor)• TP-Monitor(트랜잭션 처리 모니터)는 항공기
나 철도 예약 업무 등과 같은 온라인 트랜잭션 
업무에서 트랜잭션을 처리 및 감시하는 미들
웨어
• 사용자 수가 증가해도 빠른 응답 속도를 유지
해야 하는 업무에 주로 사용됨
ORB(Object 
Request 
Broker)• ORB(객체 요청 브로커)는 객체 지향 미들웨어
로 코바(CORBA) 표준 스펙을 구현한 미들웨어
• 최근에는 TP-Monitor의 장점인 트랜잭션 처리
와 모니터링 등을 추가로 구현한 제품도 있음
WAS(Web 
Application 
Server)• WAS(웹 애플리케이션 서버)는 정적인 콘텐츠
를 처리하는 웹 서버와 달리 사용자의 요구에 
따라 변하는 동적인 콘텐츠를 처리하기 위해 
사용되는 미들웨어
• 클라이언트/서버 환경보다는 웹 환경을 구현
하기 위한 미들웨어25.8, 25.2, 24.7, 24.5, 24.2, 22.7, 22.4, 20.8, 20.6
## 21.321.5
## 25.8, 25.2, 24.7, 24.2, 23.7, 23.5, 23.2, 22.7, 22.4, 21.8, 21.3, 20.9, 20.8, 20.6요구사항 검증 방법
2403005
069핵심
시스템 연계 기술
2403302
070핵심연계 매커니즘 구성요소
2459910
071핵심
미들웨어(Middleware)
2459954
072핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   24PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   24 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

30
정보처리기사 필기   핵심 요 약
DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구
에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 
소프트웨어이다.
• DBMS의 필수 기능
정의 기능모든 응용 프로그램들이 요구하는 데이터 구조를 지원
하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 
구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 
기능
조작 기능데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하
기 위해 사용자와 데이터베이스 사이의 인터페이스 수
단을 제공하는 기능
제어 기능데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정
확하게 수행되어 데이터의 무결성이 유지되도록 제어
해야 함
장점•데이터의 논리적, 물리적 독립성이 보장됨
•데이터의 중복을 피할 수 있어 기억 공간이 절약됨
•저장된 자료를 공동으로 이용할 수 있음
•데이터의 일관성을 유지할 수 있음
•데이터의 무결성을 유지할 수 있음
•보안을 유지할 수 있음
•데이터를 표준화할 수 있음
•데이터를 통합하여 관리할 수 있음
•항상 최신의 데이터를 유지함
•데이터의 실시간 처리가 가능함•  대수적 코딩법(Algebraic Coding)  : 키 값을 이루고 있는 
각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 
다항식을 해시표의 크기에 의해 정의된 다항식으로 나
누어 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식
•  숫자 분석법(Digit Analysis, 계수 분석법)  : 키 값을 이루는 
숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만
큼 택해서 홈 주소로 삼는 방식
•  무작위법(Random) : 난수(Random Number)를 발생시
켜 나온 값을 홈 주소로 삼는 방식단점• 데이터베이스의 전문가가 부족함
•전산화 비용이 증가함
• 대용량 디스크로의 집중적인 Access로 과부하(Overhead)
가 발생함
• 파일의 예비(Backup)와 회복(Recovery)이 어려움
•시스템이 복잡함
절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증
하고, 실행을 통해 결과를 확인하는 테스트 과정을 수행
한다.
•  테스트와 디버깅의 목적  : 테스트(Test)를 통해 오류를 발
견한 후 디버깅(Debugging)을 통해 오류가 발생한 소
스 코드를 추적하며 수정함DBMS(DataBase Management  
System; 데이터베이스 관리 시스템)
2404003
089핵심23.2
 스키마(Schema)는 데이터베이스의 구조와 제약 조건에 
관한 전반적인 명세(Specification)를 기술(Description)
한 메타데이터(Meta-Data)의 집합이다.
•  스키마는 사용자의 관점에 따라 외부 스키마, 개념 스
키마, 내부 스키마로 나누어진다. 
외부 
스키마사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 
하는 데이터베이스의 논리적 구조를 정의한 것
개념 
스키마데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프
로그램이나 사용자들이 필요로 하는 데이터를 종합한 조
직 전체의 데이터베이스로 하나만 존재함
내부 
스키마물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 
실제로 데이터베이스에 저장될 레코드의 형식을 정의하
고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 
순서 등을 나타냄25.5, 21.3, 20.9
## 25.8, 21.5DBMS의 장·단점
2404004
090핵심스키마
2404005
091핵심
절차형 SQL의 테스트와 디버깅 
2404202
092핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   30PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   30 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

47
정보처리기사 필기   핵심 요 약요구 조건 분석 요구 조건 명세서 작성
개념적  설계 개념 스키마, 트랜잭션  모델링, E-R 모델
논리적  설계목표 DBMS 에 맞는 논리 스키마 설계, 트랜잭션  
인터페이스  설계 
물리적  설계목표 DBMS 에 맞는 물리적 구조의 데이터로   
변환
구현목표 DBMS 의 DDL(데이터 정의어)로 데이터베
이스 생성, 트랜잭션  작성
논리적 설계 단계란 현실 세계에서 발생하는 자료를 컴퓨
터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 
수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 
자료 구조로 변환(mapping)시키는 과정이다. 데이터베이스 구축 3과목 FitNesse웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원
하는 테스트 프레임워크
NTAFFitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 
및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레
임워크
Selenium다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케
이션 테스트 프레임워크
watir Ruby를 사용하는 애플리케이션 테스트 프레임워크
 APM은 애플리케이션의 성능 관리를 위해 접속자, 자원 
현황, 트랜잭션 수행 내역, 장애 진단 등 다양한 모니터링 
기능을 제공하는 도구를 의미한다. 
•  APM은 리소스 방식과 엔드투엔드(End-to-End)의 두 
가지 유형이 있다.
 - 리소스 방식  : Nagios, Zabbix, Cacti 등
 -  엔드투엔드 방식  : VisualVM, 제니퍼, 스카우터 등 
개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무
한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 
현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
이다. 
•  개념적 설계 단계에서는 개념 스키마 모델링과 트랜잭
션 모델링을 병행 수행한다. 
•  개념적 설계 단계에서는 요구 분석 단계에서 나온 결과
인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그
램으로 작성한다. 
•  DBMS에 독립적인 개념 스키마를 설계한다.  23.2, 22.4 
## 24.7, 22.7, 20.6APM(Application Performance 
Management/Monitoring)
2407431
162핵심
개념적 설계(정보 모델링,  
개념화)
2407605
164핵심데이터베이스 설계 순서
2407603
163핵심
논리적 설계(데이터 모델링)
2407606
165핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   47PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   47 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

48
정보처리기사 필기   핵심 요 약
•  개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 
데이터 타입들 간의 관계로 표현되는 논리적 구조의 데
이터로 모델화한다.
•  개념적 설계가 개념 스키마를 설계하는 단계라면 논리
적 설계에서는 개념 스키마를 평가 및 정제하고 DBMS
에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.
• 트랜잭션의 인터페이스를 설계한다.
• 관계형 데이터베이스라면 테이블을 설계하는 단계이다.데이터 모델에 표시할 요소
구조
(Structure)논리적으로 표현된 개체 타입들 간의 관계로서 데이
터 구조 및 정적 성질을 표현함
연산
(Operation)데이터베이스에 저장된 실제 데이터를 처리하는 작
업에 대한 명세로서 데이터베이스를 조작하는 기본 
도구
제약 조건
(Constraint)데이터베이스에 저장될 수 있는 실제 데이터의 논리
적인 제약 조건
E-R 모델은 개념적 데이터 모델의 가장 대표적인 것으
로, 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적
인 구성 요소가 정립되었다.
•  E-R 모델은 개체 타입(Entity Type)과 이들 간의 관계 
타입(Relationship Type)을 이용해 현실 세계를 개념적
으로 표현한다.
•  E-R 모델에서는 데이터를 개체(Entity), 관계
(Relationship), 속성(Attribute)으로 묘사한다.
• E-R 모델은 특정 DBMS를 고려한 것은 아니다.
•  E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관
계 유형을 제한 없이 나타낼 수 있다.데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 
위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모
형이다.
데이터 모델의 구성 요소
개체
(Entity)데이터베이스에 표현하려는 것으로, 사람이 생각
하는 개념이나 정보 단위 같은 현실 세계의 대상체
속성
(Attribute)데이터의 가장 작은 논리적 단위로서 파일 구조상
의 데이터 항목 또는 데이터 필드에 해당함
관계
(Relationship)개체 간의 관계 또는 속성 간의 논리적인 연결을 
의미함물리적 설계란 논리적 설계 단계에서 논리적 구조로 표현
된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있
는 물리적 구조의 데이터로 변환하는 과정이다.
•  물리적 설계 단계에서는 다양한 데이터베이스 응용에 
대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 
구조 및 액세스 경로를 결정한다.
•  저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 
레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저
장되는 방법을 묘사한다.
•  물리적 설계 시 고려할 사항  : 트랜잭션 처리량, 응답 시
간, 디스크 용량, 저장 공간의 효율화 등24.5, 24.2, 22.4, 22.3, 21.8, 21.5, 21.3, 20.9
## 25.8, 24.5, 23.2, 22.4 , 20.925.5, 23.7, 22.7물리적 설계(데이터 구조화)
2407607
166핵심
데이터 모델
2459916
167핵심•  관계의 형태에는 일 대 일(1:1), 일 대 다(1:N), 다 대 다
(N:M) 관계가 있다.
•  일 대 일(1:1)  : 개체 집합 A의 각 원소가 개체 집합 B의 
원소 한 개와 대응하는 관계
•  일 대 다(1:N)  : 개체 집합 A의 각 원소는 개체 집합 B의 
원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원
소는 개체 집합 A의 원소 한 개와 대응하는 관계
•  다 대 다(N:M)  : 개체 집합 A의 각 원소는 개체 집합 B의 
원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개
체 집합 A의 원소 여러 개와 대응하는 관계25.8, 23.5
관계의 형태
2408002
168핵심
E - R 모델의 개요
2408201
169핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   48PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   48 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

49
정보처리기사 필기   핵심 요 약기호 기호 이름 의미
사각형 개체(Entity) 타입
마름모 관계(Relationship) 타입
타원 속성(Attribute)
이중 타원 다중값 속성(복합 속성)
밑줄 타원 기본키 속성
복수 타원복합 속성
 성명은 성과 이름으로 구성
N M관계1 : 1, 1 : N, N : M 등의 개체 간 관
계에 대한 대응수를 선 위에 기
술함
선, 링크 개체 타입과 속성을 연결25.5, 24.7, 24.5, 23.7, 22.7, 22.3, 21.5, 21.3, 20.9, 20.6
E-R 다이어그램
2408202
170핵심
릴레이션은 데이터들을 표(Table)의 형태로 표현한 것으
로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레
이션 인스턴스로 구성된다.
<학생> 릴레이션
 속성
학번 이름 학년신장학과 릴레이션
스키마
튜플19001 김예소 2170CD릴레이션
20002 고강민 1169CD릴레이션
인스턴스 19012 이향기 2180 ID
17032 김동준 4174ED
학년의 도메인튜플(Tuple)
• 튜플은 릴레이션을 구성하는 각각의 행을 말한다.
• 튜플은 속성의 모임으로 구성된다.
• 파일 구조에서 레코드와 같은 의미이다.
•  튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응
수라고 한다.
속성(Attribute)
•  속성은 데이터베이스를 구성하는 가장 작은 논리적 단
위이다.
• 파일 구조상의 데이터 항목 또는 데이터 필드에 해당된다.
• 속성은 개체의 특성을 기술한다.
• 속성의 수를 디그리(Degree) 또는 차수라고 한다.
도메인(Domain)
•  도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입
의 원자(Atomic)값들의 집합이다.
•  도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합
법 여부를 시스템이 검사하는데에도 이용된다.
    성별 애트리뷰트의 도메인은 ‘남’과 ‘여’로, 그 외의 
값은 입력될 수 없다.
•  한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴
레이션에 포함된 튜플들은 모두 상이하다.
    <학생> 릴레이션을 구성하는 김예소 레코드는 김예
소에 대한 학적 사항을 나타내는 것으로 <학생> 릴
레이션 내에서는 유일하다.
• 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
    <학생> 릴레이션에서 김예소 레코드와 고강민 레코
드의 위치가 바뀌어도 상관없다. 
•  튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 
시간에 따라 변한다.
    <학생> 릴레이션에 새로운 학생의 레코드를 삽입하
거나 기존 학생에 대한 레코드를 삭제함으로써 테이
블은 내용 면에서나 크기 면에서 변하게 된다. 25.8, 25.5, 24.7, 23.2, 22.4, 22.3, 21.5, 21.3, 20.9, 20.8, 20.6
## 25.8, 25.2, 24.7, 24.5, 24.2, 23.7, 22.7, 22.4, 21.5, 20.8관계형 데이터베이스의  
Relation 구조
2408402
171핵심
릴레이션의 특징
2408403
172핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   49PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   49 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

50
정보처리기사 필기   핵심 요 약
•  릴레이션 스키마를 구성하는 속성들 간의 순서는 중요
하지 않다.
    학번, 이름 등의 속성을 나열하는 순서가 이름, 학번 
순으로 바뀌어도 데이터 처리에는 아무런 영향을 미
치지 않는다.
•  속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하
지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.
    각 학생의 학년을 기술하는 속성인 ‘학년’은 다른 속성
명들과 구분되어 유일해야 하지만 ‘학년’ 속성에는 2, 
1, 2, 4 등이 입력된 것처럼 동일한 값이 있을 수 있다.
•  릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 
속성들의 부분집합을 키(Key)로 설정한다.
    <학생> 릴레이션에서는 ‘학번’이나 ‘이름’이 튜플들을 
구분하는 유일한 값인 키가 될 수 있다.
•  속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값
만을 저장한다.
    ‘학년’에 저장된 1, 2, 4 등은 더 이상 세분화할 수 없다.
키(Key)는 데이터베이스에서 조건에 만족하는 튜플을 찾
거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 
기준이 되는 애트리뷰트를 말한다.
후보키
(Candidate 
Key)• 릴레이션을 구성하는 속성들 중에서 튜플을 유일
하게 식별하기 위해 사용하는 속성들의 부분집합, 
즉 기본키로 사용할 수 있는 속성들을 말함
• 후보키는 릴레이션에 있는 모든 튜플에 대해서 유
일성과 최소성을 만족시켜야 함
기본키
(Primary 
Key)• 후보키 중에서 특별히 선정된 주키(Main Key)로 중
복된 값을 가질 수 없음
• 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 
있는 속성
• 기본키는 NULL 값을 가질 수 없다. 즉 튜플에서 기
본키로 설정된 속성에는 NULL 값이 있어서는 안 됨
대체키
(Alternate 
Key)• 후보키가 둘 이상일 때 기본키를 제외한 나머지 후
보키를 의미함
•보조키라고도 함슈퍼키
(Super 
Key)• 한 릴레이션 내에 있는 속성들의 집합으로 구성된 
키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼
키로 구성된 속성의 집합과 동일한 값은 나타나지 
않음
• 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 
유일성은 만족시키지만, 최소성은 만족시키지 못함
외래키
(Foreign 
Key)• 다른 릴레이션의 기본키를 참조하는 속성 또는 속성
들의 집합을 의미함
• 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본
키인 B가 동일한 도메인 상에서 정의되었을 때의 속
성 A를 외래키라고 함
관계대수는 관계형 데이터베이스에서 원하는 정보와 그 
정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 
절차적인 언어이다.
•  관계대수는 릴레이션을 처리하기 위해 연산자와 연산
규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결
과도 릴레이션이다.
•  질의에 대한 해를 구하기 위해 수행해야 할 연산의 순
서를 명시한다. 25.8, 25.5, 25.2, 24.7, 24.5, 23.7, 23.5, 23.2, 22.7, 22.4, 22.3, 21.8, 20.9, 20.6무결성이란 데이터베이스에 저장된 데이터 값과 그것이 
표현하는 현실 세계의 실제값이 일치하는 정확성을 의미
한다.
•  개체 무결성(Entity Integrity, 실체 무결성)  : 기본 테이블의 
기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 
가질 수 없다는 규정
•  도메인 무결성(Domain Integrity, 영역 무결성)  : 주어진 속
성 값이 정의된 도메인에 속한 값이어야 한다는 규정
•  참조 무결성(Referential Integrity)  : 외래키 값은 Null이거
나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴
레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 
규정
•  사용자 정의 무결성(User-Defined Integrity)  : 속성 값들이 
사용자가 정의한 제약조건에 만족해야 한다는 규정25.5, 25.2, 24.5, 24.2, 23.2, 22.7, 22.4, 21.8, 21.5, 21.3, 20.8, 20.6
## 25.2, 24.7, 24.5, 24.2, 22.7, 21.8, 21.5, 21.3, 20.9, 20.8키(Key)
2459917
173핵심무결성(Integrity)
2459918
174핵심
관계대수의 개요
2459919
175핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   50PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   50 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

51
정보처리기사 필기   핵심 요 약관계해석은 관계 데이터 모델의 제안자인 코드(E. F. 
Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 
두고 관계 데이터베이스를 위해 제안했다.
•  관계해석은 관계 데이터의 연산을 표현하는 방법으로, 
원하는 정보를 정의할 때는 계산 수식을 사용한다.
•  관계해석은 원하는 정보가 무엇이라는 것만 정의하는 
비절차적 특성을 지닌다.
• 튜플 관계해석과 도메인 관계해석이 있다.
•  기본적으로 관계해석과 관계대수는 관계 데이터베이스
를 처리하는 기능과 능력면에서 동등하며, 관계대수로 
표현한 식은 관계해석으로 표현할 수 있다.
• 질의어로 표현한다.
• 주요 논리기호
기호 구성 요소 설명
∀전칭 정량자 가능한 모든 튜플에 대하여(For All)
∃존재 전량자 하나라도 일치하는 튜플이 있음(There Exists)•  관계대수에는 관계 데이터베이스에 적용하기 위해 특
별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 
사용하는 일반 집합 연산자가 있다.
• 순수 관계 연산자  
 - Select
 - Project
 - Join
 - Division 
• 일반 집합 연산자
 - UNION(합집합)
 - INTERSECTION(교집합)
 - DIFFERENCE(차집합)
 - CARTESIAN PRODUCT(교차곱)
Select릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 
튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
• 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이
므로 수평 연산이라고도 함
•연산자의 기호는 그리스 문자 시그마(σ)를 사용함
Project주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 
속성 값만을 추출하여 새로운 릴레이션을 만드는 연산이
다. 단 연산 결과에 중복이 발생하면 중복이 제거됨
• 릴레이션의 열(세로)에 해당하는 Attribute를 추출하는 
것이므로 수직 연산자라고도 함
•연산자의 기호는 그리스 문자 파이(π)를 사용함
Join공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐
서 새로운 릴레이션을 만드는 연산
•연산자의 기호는  를 사용함
DivisionX⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성
이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제
외한 속성만을 구하는 연산
•연산자의 기호는 ÷를 사용함연산자 기능 및 수학적 표현 카디널리티
합집합
UNION
∪두 릴레이션에 존재하
는 튜플의 합집합을 구
하되, 결과로 생성된 릴
레이션에서 중복되는 
튜플은 제거되는 연산합집합의 카디널리티는 
두 릴레이션 카디널리
티의 합보다 크지 않음
교집합
INTERSECTION
∩두 릴레이션에 존재하
는 튜플의 교집합을 구
하는 연산교집합의 카디널리티는 
두 릴레이션 중 카디널
리티가 적은 릴레이션
의 카디널리티보다 크
지 않음
차집합
DIFFERENCE
-두 릴레이션에 존재하
는 튜플의 차집합을 구
하는 연산차집합의 카디널리티는 
릴레이션 R의 카디널리
티 보다 크지 않음
교차곱
CARTESIAN 
PRODUCT 
×두 릴레이션에 있는 튜
플들의 순서쌍을 구하
는 연산교차곱의 디그리는 두 
릴레이션의 디그리를 
더한 것과 같고, 카디널
리티는 두 릴레이션의 
카디널리티를 곱한 것
과 같음
## 25.5, 24.5, 23.7, 23.2, 22.3, 21.3, 20.8, 20.625.8, 25.2, 24.5, 24.2, 23.7, 23.5, 21.8, 21.5
## 25.5, 24.7, 23.7, 23.2, 22.7, 22.3
순수 관계 연산자
2459961
176핵심일반 집합 연산자
2408706
177핵심
관계해석(Relational Calculus)
2408707
178핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   51PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   51 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

52
정보처리기사 필기   핵심 요 약
정규화란 함수적 종속성 등의 종속성 이론을 이용하여 잘
못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 
바람직한 스키마로 만들어 가는 과정이다.
•  하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 
분해해가는 과정이라 할 수 있다.
•  정규형에는 제1정규형, 제2정규형, 제3정규형, BCNF
형, 제4정규형, 제5정규형이 있으며, 차수가 높아질수
록 만족시켜야 할 제약 조건이 늘어난다.
•  정규화는 데이터베이스의 논리적 설계 단계에서 수행
한다.
• 정규화는 논리적 처리 및 품질에 큰 영향을 미친다.
•  정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중
복성, 안정성 등을 보장한다.
• 데이터 구조의 안정성 및 무결성을 유지한다.
•  어떠한 릴레이션이라도 데이터베이스 내에서 표현 가
능하게 만든다.
• 효과적인 검색 알고리즘을 생성할 수 있다.
•  데이터 중복을 배제하여 이상(Anomaly)의 발생 방지 
및 자료 저장 공간의 최소화가 가능하다.
• 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
• 데이터 모형의 단순화가 가능하다.
• 속성의 배열 상태 검증이 가능하다.
• 개체와 속성의 누락 여부 확인이 가능하다.
• 자료 검색과 추출의 효율성을 추구한다.비정규 릴레이션
  도메인이 원자값
1NF
  부분적 함수 종속 제거
2NF
  이행적 함수 종속 제거
3NF
  결정자이면서 후보키가 아닌 것 제거
BCNF
  다치 종속 제거
4NF
  조인 종속성 이용
5NF정규화를 거치지 않으면 데이터베이스 내에 데이터들이 
불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란
한 현상이 발생하는데, 이를 이상(Anomaly)이라 하며 삽
입 이상, 삭제 이상, 갱신 이상이 있다.
삽입 이상
(Insertion 
Anomaly)릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원
하지 않은 값들도 함께 삽입되는 현상
삭제 이상
(Deletion 
Anomaly)릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 
값들도 함께 삭제되는 연쇄가 일어나는 현상
갱신 이상
(Update 
Anomaly)릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜
플의 정보만 갱신되어 정보에 모순이 생기는 현상25.2, 24.5, 24.2, 21.8, 21.5, 21.3, 20.8 25.8, 25.2, 23.7, 23.5, 22.7, 21.8, 20.9
## 23.2, 21.8, 20.825.5, 25.2, 24.7, 24.5, 24.2, 23.7, 23.5, 23.2, 22.7, 22.4, 22.3, 21.8, 21.5, …이상(Anomaly)의 개념 및  
종류
2408803
181핵심정규화의 개요
2408801
179핵심
정규화의 목적
2408802
180핵심정규화 과정
2408805
182핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   52PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   52 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

53
정보처리기사 필기   핵심 요 약정규화  단계 암기 요령
두부를  좋아하는  정규화가  두부가게에  가서 가게에  있는 두부를 
다 달라고  말하니 주인이  깜짝 놀라며  말했다 .
두부이걸다줘 ? ≒ 도부이결다조
도메인이  원자값
부분적 함수 종속 제거
이행적 함수 종속 제거
결정자이면서  후보키가  아닌 것 제거
다치 종속 제거
조인 종속성  이용
반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 
등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 
과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.
•  반정규화를 수행하면 시스템의 성능이 향상되고 관리 
효율성은 증가하지만 데이터의 일관성 및 정합성이 저
하될 수 있다.
•  과도한 반정규화는 오히려 성능을 저하시킬 수 있다.
•  반정규화를 위해서는 사전에 데이터의 일관성과 무결
성을 우선으로 할지, 데이터베이스의 성능과 단순화를 
우선으로 할지를 결정해야 한다.
•  반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테
이블 추가, 중복 속성 추가 등이 있다.테이블 
통합• 두 개의 테이블이 조인(Join)되는 경우가 많아 하나의 
테이블로 합쳐 사용하는 것이 성능 향상에 도움이 
될 경우 수행함
• 두 개의 테이블에서 발생하는 프로세스가 동일하게 
자주 처리되는 경우, 두 개의 테이블을 이용하여 항
상 조회를 수행하는 경우 테이블 통합을 고려함
테이블 
분할• 테이블을 수직 또는 수평으로 분할하는 것
• 수평 분할(Horizontal Partitioning) : 레코드(Record)를 
기준으로 테이블을 분할하는 것
• 수직 분할(Vertical Partitioning) : 하나의 테이블에 속
성이 너무 많을 경우 속성을 기준으로 테이블을 분
할하는 것
중복 
테이블 
추가• 여러 테이블에서 데이터를 추출해서 사용해야 하거
나 다른 서버에 저장된 테이블을 이용해야 하는 경
우 중복 테이블을 추가하여 작업의 효율성을 향상시
킬 수 있음
• 중복 테이블 추가 방법 : 집계 테이블의 추가, 진행 테
이블의 추가, 특정 부분만을 포함하는 테이블의 추가
중복 속성 
추가조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 
단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 
것
시스템 카탈로그는 시스템 그 자체에 관련이 있는 다양한 
객체에 관한 정보를 포함하는 시스템 데이터베이스이다.
•  시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 
DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 
명세에 관한 정보를 유지 관리하는 시스템 테이블이다.
•  카탈로그들이 생성되면 데이터 사전(Data Dictionary)
에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 
사전이라고도 한다.
•  시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-
Data)라고 한다.
•  카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 
이용자도 SQL을 이용하여 내용을 검색해 볼 수 있다.
•  INSERT, DELETE, UPDATE문으로 카탈로그를 갱신
하는 것은 허용되지 않는다.
• 데이터베이스 시스템에 따라 상이한 구조를 갖는다.
• 카탈로그는 DBMS가 스스로 생성하고 유지한다. 이행적 종속(Transitive Dependency) 관계
A → B이고 B → C일 때 A → C를 만족하는 관계를 의미
한다.
함수적 종속(Functional Dependency)
•  함수적 종속은 데이터들이 어떤 기준값에 의해 종속되
는 것을 의미한다. 
•  예를 들어 <수강> 릴레이션이 (학번, 이름, 과목명)으
로 되어 있을 때, ‘학번’이 결정되면 ‘과목명’에 상관없이 
‘학번’에는 항상 같은 ‘이름’이 대응된다. ‘학번’에 따라 
‘이름’이 결정될 때 ‘이름’을 ‘학번’에 함수 종속적이라고 
하며 ‘학번 → 이름’과 같이 쓴다.24.5, 24.2, 22.3, 21.8, 20.8, 20.6
## 25.5, 24.2, 23.7, 20.920.6
## 25.8, 25.5, 24.7, 24.5, 24.2, 23.7, 22.7, 22.4, 21.5, 21.3이행적 종속 / 함수적 종속
2408831
183핵심
반정규화의 개 요
2408901
184핵심반정규화 방법
2459920
185핵심
시스템 카탈로그
2459921
186핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   53PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   53 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

54
정보처리기사 필기   핵심 요 약
•  카탈로그의 갱신  : 사용자가 SQL문을 실행시켜 기본 테
이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 
갱신함
※ Data Directory
  -  데이터 사전에 수록된 데이터를 실제로 접근하는 데 
필요한 정보를 관리 유지하는 시스템이다.
  -  시스템 카탈로그는 사용자와 시스템 모두 접근할 수 
있지만 데이터 디렉터리는 시스템만 접근할 수 있다.
• 활동(Active)  : 트랜잭션이 실행 중인 상태
•  실패(Failed)  : 트랜잭션 실행에 오류가 발생하여 중단된 
상태
•  철회(Aborted)  : 트랜잭션이 비정상적으로 종료되어 
Rollback 연산을 수행한 상태
•  부분 완료(Partially Committed)  : 트랜잭션을 모두 성공적
으로 실행한 후 Commit 연산이 실행되기 직전인 상태
•  완료(Committed)  : 트랜잭션을 모두 성공적으로 실행한 
후 Commit 연산을 실행한 후의 상태Atomicity
(원자성)• 트랜잭션의 연산은 데이터베이스에 모두 반영되
도록 완료(Commit)되든지 아니면 전혀 반영되지 
않도록 복구(Rollback)되어야 함
• 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되
어야 하며, 모두가 완벽히 수행되지 않고 어느 하
나라도 오류가 발생하면 트랜잭션 전부가 취소되
어야 함
Consistency
(일관성)• 트랜잭션이 그 실행을 성공적으로 완료하면 언제
나 일관성 있는 데이터베이스 상태로 변환함
• 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 
전과 트랜잭션 수행 완료 후의 상태가 같아야 함
Isolation
(독립성, 
격리성, 
순차성)• 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 
어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 
연산이 끼어들 수 없음
• 수행중인 트랜잭션은 완전히 완료될 때까지 다른 
트랜잭션에서 수행 결과를 참조할 수 없음
Durability
(영속성, 
지속성)성공적으로 완료된 트랜잭션의 결과는 시스템이 고장
나더라도 영구적으로 반영되어야 함
CRUD는 ‘생성(Create), 읽기(Read), 갱신(Update), 삭
제(Delete)’의 앞 글자만 모아서 만든 용어이며, CRUD 
분석은 데이터베이스 테이블에 변화를 주는 트랜잭션의 
CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하
는 것이다.
•  CRUD 분석으로 테이블에 발생되는 트랜잭션의 주기
별 발생 횟수를 파악하고 연관된 테이블들을 분석하면 
테이블에 저장되는 데이터의 양을 유추할 수 있다.트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논
리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모
두 수행되어야 할 일련의 연산들을 의미한다.
•  트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회
복 작업 시 처리되는 작업의 논리적 단위로 사용된다.
•  트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시
스템이 응답하기 위한 상태 변환 과정의 작업 단위로 
사용된다.23.2, 22.7, 22.4, 22.3, 21.8
## 23.7, 22.7, 22.4, 22.325.8, 25.5, 25.2, 24.7, 24.5, 24.2, 23.7, 23.5, 23.2, 22.7, 22.4, 21.8, 21.3, …
## 22.7, 20.9트랜잭션
2409301
187핵심
트랜잭션의 상태
2459922
188핵심트랜잭션의 특성
2409302
189핵심
CRUD 분석
2409303
190핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   54PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   54 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

57
정보처리기사 필기   핵심 요 약•  분할은 테이블의 데이터를 분할하여 분산시키는 것이
다.
• 분할 규칙
완전성
(Completeness)전체 데이터를 대상으로 분할해야 함
재구성
(Reconstruction)분할된 데이터는 관계 연산을 활용하여 본래의 데
이터로 재구성할 수 있어야 함
상호 중첩 배제
(Dis-jointness)분할된 데이터는 서로 다른 분할의 항목에 속하
지 않아야 함
• 주요 분할 방법
수평 분할 특정 속성의 값을 기준으로 행(Row) 단위로 분할함
수직 분할 데이터 컬럼(속성) 단위로 분할함•  데이터를 암호화할 때 사용하는 키(공개키, Public 
Key)는 데이터베이스 사용자에게 공개하고, 복호화할 
때의 키(비밀키, Secret Key)는 관리자가 비밀리에 관
리 하는 방법이다. 
•  공개키 암호화 기법은 비대칭 암호 방식이라고도 하며, 
대표적으로 RSA(Rivest Shamir Adleman)가 있다. 25.2
분할(Fragment)
2409908
198핵심
암호화는 데이터를 보낼 때 송신자가 지정한 수신자 이외
에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 
것이다.
•  암호화(Encryption) 과정  : 암호화되지 않은 평문을 정보 
보호를 위해 암호문으로 바꾸는 과정
•  복호화(Decryption) 과정  : 암호문을 원래의 평문으로 바
꾸는 과정
 개인키 암호 방식(Private Key Encryption) = 비밀키 암호 방식
 비밀키 암호화 기법은 동일한 키로 데이터를 암호화하고 
복호화한다.
•  비밀키 암호화 기법은 대칭 암호 방식 또는 단일키 암
호화 기법이라고도 한다. 
•  비밀키는 제3자에게는 노출시키지 않고 데이터베이스 
사용 권한이 있는 사용자만 나누어 가진다. 
•  종 류 : 전위 기법, 대체 기법, 대수 기법, 합성 기법
(DES, LUCIFER)  
공개키 암호 방식(Public Key Encryption) 
공개키 암호화 기법은 서로 다른 키로 데이터를 암호화하
고 복호화한다.임의 접근통제(DAC; Discretionary Access Control)
•  임의 접근통제는 데이터에 접근하는 사용자의 신원에 
따라 접근 권한을 부여하는 방식이다.
• 데이터 소유자가 접근통제 권한을 지정하고 제어한다.
•  객체를 생성한 사용자가 생성된 객체에 대한 모든 권한
을 부여받고, 부여된 권한을 다른 사용자에게 허가할 
수도 있다. 
•  임의 접근통제에 사용되는 SQL 명령어에는 GRANT와 
REVOKE가 있다.
강제 접근통제(MAC; Mandatory Access Control)
•  강제 접근통제는 주체와 객체의 등급을 비교하여 접근 
권한을 부여하는 방식이다.
• 시스템이 접근통제 권한을 지정한다.
•  데이터베이스 객체별로 보안 등급을 부여할 수 있고, 
사용자별로 인가 등급을 부여할 수 있다.
•  주체는 자신보다 보안 등급이 높은 객체에 대해 읽기, 
수정, 등록이 모두 불가능하고, 보안 등급이 같은 객체
에 대해서는 읽기, 수정, 등록이 가능하고, 보안 등급이 
낮은 객체는 읽기가 가능하다.
역할기반 접근통제(RBAC; Role Based Access Control)
•  역할기반 접근통제는 사용자의 역할에 따라 접근 권한
을 부여하는 방식이다.
• 중앙관리자가 접근 통제 권한을 지정한다.
•  임의 접근통제와 강제 접근통제의 단점을 보완하였으
며, 다중 프로그래밍 환경에 최적화된 방식이다.
•  중앙관리자가 역할마다 권한을 부여하면, 책임과 자질
에 따라 역할을 할당받은 사용자들은 역할에 해당하는 
권한을 사용할 수 있다.21.324.5, 24.2, 23.5, 22.4, 21.8. 21.3, 20.9
암호화(Encryption)
2459927
199핵심접근통제 기술
2410201
200핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   57PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   57 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

58
정보처리기사 필기   핵심 요 약
SAN은 DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼
합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워
크를 별도로 구성하는 방식이다.
• 광 채널(FC) 스위치를 이용하여 네트워크를 구성한다.
•  광 채널 스위치는 서버나 저장장치를 광케이블로 연결
하므로 처리 속도가 빠르다.
•  저장장치를 공유함으로써 여러 개의 저장장치나 백업 
장비를 단일화시킬 수 있다.
• 확장성, 유연성, 가용성이 뛰어나다.
•  높은 트랜잭션 처리에 효과적이나 기존 시스템의 경우 
장비의 업그레이드가 필요하고, 초기 설치 시에는 별도
의 네트워크를 구축해야 하므로 비용이 많이 든다.
•  DAS에서 사용되는 프로토콜에는 SATA, eSATA, 
SCSI, SAS 등이 있다.
•  SAN에서 사용되는 프로토콜에는 iSCSI, FC, FCoE 등
이 있다.
 DDL은 SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 
정의하거나 변경 또는 삭제할 때 사용하는 언어이다.
•  논리적 데이터 구조와 물리적 데이터 구조의 사상을 정
의한다.
•  데이터베이스 관리자나 데이터베이스 설계자가 사용  
한다.
•  DDL(데이터 정의어)의 세 가지 유형
명령어 기능
CREATE SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의함
ALTER TABLE에 대한 정의를 변경하는 데 사용함
DROP SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제함DAS는 서버와 저장장치를 전용 케이블로 직접 연결하는 
방식으로, 일반 가정에서 컴퓨터에 외장하드를 연결하는 
것이 여기에 해당된다.
• 서버에서 저장장치를 관리한다.
•  저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운
영이 쉽다.
• 초기 구축 비용 및 유지보수 비용이 저렴하다.
•  직접 연결 방식이므로 다른 서버에서 접근할 수 없고 
파일을 공유할 수 없다.
• 확장성 및 유연성이 상대적으로 떨어진다.
•  저장 데이터가 적고 공유가 필요 없는 환경에 적합  
하다.
•  DAS에서 사용되는 프로토콜에는 SATA, eSATA, 
SCSI, SAS 등이 있다.25.8, 24.5, 23.7, 22.3, 20.9
## 25.5, 25.2, 24.2, 23.7, 23.2, 22.7, 21.8, 21.5, 20.625.2, 22.7, 21.5
DAS 
(Direct Attached Storage)
2410402
202핵심SAN 
(Storage Area Network)
2410404
203핵심
DDL(Data Define Language,  
데이터 정의어)
2459928
204핵심벨 라파듈라 모델(Bell-LaPadula Model)
•  군대의 보안 레벨처럼 정보의 기밀성에 따라 상하 관계
가 구분된 정보를 보호하기 위해 사용한다.
•  보안 취급자의 등급을 기준으로 읽기 권한과 쓰기 권한
이 제한된다.
•  자신의 보안 레벨 이상의 문서를 작성할 수 있고, 자신
의 보안 레벨 이하의 문서를 읽을 수 있다. 
비바 무결성 모델(Biba Integrity Model)
•  벨 라파듈라 모델을 보완한 수학적 모델로, 무결성을 
보장하는 최초의 모델이다.
• 비인가자에 의한 데이터 변형을 방지한다.
클락-윌슨 무결성 모델(Clark-Wilson Integrity Model)
무결성 중심의 상업용 모델로, 사용자가 직접 객체에 접
근할 수 없고 프로그램에 의해 접근이 가능한 보안 모델  
이다.
만리장성 모델(Chinese Wall Model)
서로 이해 충돌 관계에 있는 객체 간의 정보 접근을 통제
하는 모델이다.21.5
강제 접근통제(MAC)의  
보안 모델
2410231
201핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   58PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   58 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

59
정보처리기사 필기   핵심 요 약 DML은 데이터베이스 사용자가 응용 프로그램이나 질의
어를 통하여 저장된 데이터를 실질적으로 처리하는 데 사
용되는 언어이다.
•  데이터베이스 사용자와 데이터베이스 관리 시스템 간
의 인터페이스를 제공한다.
• DML(데이터 조작어)의 네 가지 유형
명령어 기능
SELECT 테이블에서 조건에 맞는 튜플을 검색함
INSERT 테이블에 새로운 튜플을 삽입함
DELETE 테이블에서 조건에 맞는 튜플을 삭제함
UPDATE 테이블에서 조건에 맞는 튜플의 내용을 변경함
 DCL은 데이터의 보안, 무결성, 회복, 병행 수행 제어 등
을 정의하는 데 사용되는 언어이다.
•  데이터베이스 관리자가 데이터 관리를 목적으로 사용
한다.
• DCL(데이터 제어어)의 종류
명령어 기능
COMMIT명령에 의해 수행된 결과를 실제 물리적 디스크로 저
장하고, 데이터베이스 조작 작업이 정상적으로 완료
되었음을 관리자에게 알려줌
ROLLBACK데이터베이스 조작 작업이 비정상적으로 종료되었을 
때 원래의 상태로 복구함
GRANT 데이터베이스 사용자에게 사용 권한을 부여함
REVOKE 데이터베이스 사용자의 사용 권한을 취소함CREATE TABLE은 테이블을 정의하는 명령문이다.
표기 형식
CREATE TABLE  테이블명
 (속성명 데이터_타입 [ DEFAULT  기본값] [ NOT NULL ], …
 [, PRIMARY KEY (기본키_속성명, …)]
 [, UNIQUE (대체키_속성명, …)]
 [, FOREIGN KEY (외래키_속성명, …)]
  [ REFERENCES  참조테이블(기본키_속성명, …)]
  [ ON DELETE  옵션]
  [ ON UPDATE  옵션]
 [, CONSTRAINT  제약조건명] [ CHECK  (조건식)]);
•  기본 테이블에 포함될 모든 속성에 대하여 속성명과 그 
속성의 데이터 타입, 기본값, NOT NULL 여부를 지정
한다.
•  PRIMARY KEY  : 기본키로 사용할 속성 또는 속성의 집
합을 지정함
•  UNIQUE  : 대체키로 사용할 속성 또는 속성의 집합을 지
정하는 것으로 UNIQUE로 지정한 속성은 중복된 값을 
가질 수 없음
•  FOREIGN KEY ~ REFERENCES ~
 -  참조할 다른 테이블과 그 테이블을 참조할 때 사용할 
외래키 속성을 지정함
 -  외래키가 지정되면 참조 무결성의 CASCADE 법칙
이 적용됨
 -   ON DELETE 옵션  : 참조 테이블의 튜플이 삭제되었
을 때 기본 테이블에 취해야 할 사항을 지정함. 옵션
에는 NO ACTION, CASCADE, SET NULL, SET 
DEFAULT가 있음
 -   ON UPDATE 옵션  : 참조 테이블의 참조 속성 값이 
변경되었을 때 기본 테이블에 취해야 할 사항을 지
정한다. 옵션에는 NO ACTION, CASCADE, SET 
NULL, SET DEFAULT가 있음
•  CONSTRAINT  : 제약 조건의 이름을 지정함. 이름을 지
정할 필요가 없으면 CHECK절만 사용하여 속성 값에 
대한 제약 조건을 명시함
•  CHECK  : 속성 값에 대한 제약 조건을 정의함25.8, 24.2, 23.5, 23.2, 22.3
## 24.7, 23.7, 22.4, 22.3, 20.8, 20.625.8, 25.5, 24.7, 23.5, 22.4, 20.8, 20.6
DML(Data Manipulation 
Language, 데이터 조작어)
2459929
205핵심
DCL(Data Control Language,  
데이터 제어어)
2459930
206핵심CREATE TABLE
407204
207핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   59PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   59 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

60
정보처리기사 필기   핵심 요 약
ALTER TABLE은 테이블에 대한 정의를 변경하는 명령
문이다.
표기 형식
ALTER TABLE  테이블명 ADD 속성명 데이터_타입   [DEFAULT ‘ 기
본값’];
ALTER TABLE  테이블명 ALTER  속성명 [SET DEFAULT ‘ 기본값’];
ALTER TABLE  테이블명 DROP COLUMN  속성명 [CASCADE];
• ADD : 새로운 속성(열)을 추가할 때 사용함
• ALTER : 특정 속성의 Default 값을 변경할 때 사용함
• DROP COLUMN  : 특정 속성을 삭제할 때 사용함
예제 1 <학생> 테이블에 최대 3문자로 구성되는 ‘학년’ 속
성 추가하시오.
ALTER TABLE 학생 ADD 학년 VARCHAR(3);
예제 2 <학생> 테이블의 ‘학번’ 필드의 데이터 타입과 크기
를 VARCHAR(10)으로 하고 NULL 값이 입력되지 않도
록 변경하시오.
ALTER TABLE 학생 ALTER 학번 VARCHAR(10) NOT NULL;
DROP은 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱
스, 제약 조건 등을 제거하는 명령문이다. 
표기 형식
DROP SCHEMA  스키마명 [CASCADE | RESTRICT];
DROP DOMAIN  도메인명 [CASCADE | RESTRICT];
DROP TABLE  테이블명 [CASCADE | RESTRICT];
DROP VIEW  뷰명 [CASCADE | RESTRICT];
DROP INDEX  인덱스명 [CASCADE | RESTRICT];
DROP CONSTRAINT  제약조건명;
•  CASCADE  : 제거할 요소를 참조하는 다른 모든 개체를 
함께 제거함. 즉 주 테이블의 데이터 제거 시 각 외래키
와 관계를 맺고 있는 모든 데이터를 제거하는 참조 무
결성 제약 조건을 설정하기 위해 사용됨
•  RESTRICT  : 다른 개체가 제거할 요소를 참조중일 때는 
제거를 취소함예제 <학생> 테이블을 제거하되, <학생> 테이블을 참조
하는 모든 데이터를 함께 제거하시오.
DROP TABLE 학생 CASCADE;
데이터베이스 관리자가 데이터베이스 사용자에게 권한을 
부여하거나 취소하기 위한 명령어이다.
• GRANT  : 권한 부여를 위한 명령어
• REVOKE  : 권한 취소를 위한 명령어
• 사용자등급 지정 및 해제
- GRANT  사용자등급  TO 사용자_ID_리스트 [IDENTIFIED BY 암호];
- REVOKE  사용자등급  FROM 사용자_ID_리스트;
예제 1 사용자 ID가 “NABI”인 사람에게 데이터베이스 및 
테이블을 생성할 수 있는 권한을 부여하는 SQL문을 작성
하시오.
GRANT RESOURCE TO NABI;
예제 2 사용자 ID가 “STAR”인 사람에게 단순히 데이터베
이스에 있는 정보를 검색할 수 있는 권한을 부여하는 SQL
문을 작성하시오.
GRANT CONNECT TO STAR;
• 테이블 및 속성에 대한 권한 부여 및 취소
-  GRANT  권한_리스트  ON 개체 TO 사용자  [WITH GRANT 
OPTION];
-  REVOKE  [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사
용자 [CASCADE];DCL(데이터 제어어)는 데이터의 보안, 무결성, 회복, 병
행 제어 등을 정의하는 데 사용하는 언어이다. 
•  DCL은 데이터베이스 관리자(DBA)가 데이터 관리를 목
적으로 사용한다.
•  DCL에는 GRANT, REVOKE, COMMIT, ROLLBACK, 
SAVEPOINT 등이 있다. 21.3, 20.9
## 25.8, 24.7, 23.2, 22.3, 21.5, 20.625.8, 24.5, 24.2, 22.7, 22.4, 22.3, 20.9DCL(Data Control Language,  
데이터 제어어)의 개 요
407301
210핵심ALTER TABLE
407207
208핵심
DROP
407208
209핵심GRANT / REVOKE
407302
211핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   60PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   60 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

61
정보처리기사 필기   핵심 요 약 -  권한 종류  : ALL, SELECT, INSERT, DELETE, 
UPDATE, ALTER 등
 -   WITH GRANT OPTION  : 부여받은 권한을 다른 사용자
에게 다시 부여할 수 있는 권한을 부여함
 -  GRANT OPTION FOR  : 다른 사용자에게 권한을 부여
할 수 있는 권한을 취소함
 -   CASCADE  : 권한 취소 시 권한을 부여받았던 사용자가 
다른 사용자에게 부여한 권한도 연쇄적으로 취소함
예제 3 사용자 ID가 “NABI”인 사람에게 <고객> 테이블에 
대한 모든 권한과 다른 사람에게 권한을 부여할 수 있는 
권한까지 부여하는 SQL문을 작성하시오.
GRANT ALL ON 고객 TO NABI WITH GRANT OPTION;
예제 4 사용자 ID가 “STAR”인 사람에게 부여한 <고객> 
테이블에 대한 권한 중 UPDATE 권한을 다른 사람에게 
부여할 수 있는 권한만 취소하는 SQL문을 작성하시오.
REVOKE GRANT OPTION FOR UPDATE ON 고객 FROM STAR;
ROLLBACK은 아직 COMMIT되지 않은 변경된 모든 내
용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 
명령어이다.
•  트랜잭션 전체가 성공적으로 끝나지 못하면 일부 변
경된 내용만 데이터베이스에 반영되는 비일관성
(Inconsistency)인 상태를 가질 수 있기 때문에 일부분
만 완료된 트랜잭션은 롤백(Rollback)되어야 한다.삽입문은 기본 테이블에 새로운 튜플을 삽입할 때 사용한다. 
일반 형식
INSERT INTO  테이블명 ([속성명1, 속성명2,…])
VALUES  (데이터1, 데이터2,… );
•  대응하는 속성과 데이터는 개수와 데이터 유형이 일치
해야 한다.
•  기본 테이블의 모든 속성을 사용할 때는 속성명을 생략
할 수 있다.
•  SELECT문을 사용하여 다른 테이블의 검색 결과를 삽
입할 수 있다.
<사원>
이름 부서 생일 주소 기본급
홍길동 기획 04/05/61 망원동 120
임꺽정 인터넷 01/09/69 성산동 80
황진이 편집 07/21/75 연희동 100
김선달 편집 10/22/73 망원동 90
성춘향 기획 02/20/64 망원동 100
장길산 편집 03/11/67 상암동 120
일지매 기획 04/29/78 합정동 110
강호동 인터넷 12/11/80 90
예제 1 <사원> 테이블에 (이름 - 홍승현, 부서 - 인터넷)
을 삽입하시오.
INSERT INTO 사원(이름, 부서) VALUES (‘홍승현’, ‘인터넷’);
예제 2 <사원> 테이블에 (장보고, 기획, 05/03/73, 홍제
동, 90)을 삽입하시오.
INSERT INTO 사원 VALUES (‘장보고’, ‘기획’, #05/03/73#, ‘홍제
동’, 90);
예제 3 <사원> 테이블에 있는 편집부의 모든 튜플을 편집
부원(이름, 생일, 주소, 기본급) 테이블에 삽입하시오.
INSERT INTO 편집부원(이름, 생일, 주소, 기본급)
SELECT 이름, 생일, 주소, 기본급
FROM 사원
WHERE 부서 = ‘편집’;트랜잭션이 성공적으로 끝나면  데이터베이스가 새로운 
일관성(Consistency) 상태를 가지기 위해 변경된 모든 내
용을 데이터베이스에 반영하여야 하는데, 이때 사용하는 
명령이 COMMIT이다.
•  COMMIT 명령을 실행하지 않아도 DML문이 성공적으
로 완료되면 자동으로 COMMIT되고, DML이 실패하
면 자동으로 ROLLBACK이 되도록 Auto Commit 기
능을 설정할 수 있다.22.3
## 22.3, 21.523.7, 23.5
COMMIT
407303
212핵심
ROLLBACK
407304
213핵심삽입문(INSERT INTO~)
407402
214핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   61PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   61 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

62
정보처리기사 필기   핵심 요 약
삭제문은 기본 테이블에 있는 튜플들 중에서 특정 튜플
(행)을 삭제할 때 사용한다. 
일반 형식
DELETE
FROM 테이블명
[WHERE  조건];
•  모든 레코드를 삭제할 때는 WHERE절을 생략한다.
•  모든 레코드를 삭제하더라도 테이블 구조는 남아 있기 
때문에 디스크에서 테이블을 완전히 제거하는 DROP과
는 다르다.
<사원>
이름 부서 생일 주소 기본급
홍길동 기획 04/05/61 망원동 120
임꺽정 인터넷 01/09/69 성산동 80
황진이 편집 07/21/75 연희동 100
김선달 편집 10/22/73 망원동 90
성춘향 기획 02/20/64 망원동 100
장길산 편집 03/11/67 상암동 120
일지매 기획 04/29/78 합정동 110
강호동 인터넷 12/11/80 90
예제 <사원> 테이블에서 “임꺽정”에 대한 튜플을 삭제하
시오.
DELETE
FROM 사원
WHERE 이름 = ‘임꺽정’;갱신문은 기본 테이블에 있는 튜플들 중에서 특정 튜플의 
내용을 변경할 때 사용한다.
일반 형식
UPDATE  테이블명
SET 속성명 = 데이터[, 속성명=데이터, …]
[WHERE  조건];
<사원>
이름 부서 생일 주소 기본급
홍길동 기획 04/05/61 망원동 120
임꺽정 인터넷 01/09/69 성산동 80
황진이 편집 07/21/75 연희동 100
김선달 편집 10/22/73 망원동 90
성춘향 기획 02/20/64 망원동 100
장길산 편집 03/11/67 상암동 120
일지매 기획 04/29/78 합정동 110
강호동 인터넷 12/11/80 90
예제 <사원> 테이블에서 “황진이”의 ‘부서’를 “기획부”로 
변경하고 ‘기본급’을 5만 원 인상시키시오.
UPDATE 사원
SET 부서 = ‘기획’, 기본급 = 기본급 + 5
WHERE 이름 = ‘황진이’;
• SELECT(검색) : SELECT~ FROM~ WHERE~
• INSERT(삽입)  : INSERT INTO~ VALUES~
• DELETE(삭제)  : DELETE~ FROM~ WHERE~
• UPDATE(변경)  : UPDATE~ SET~ WHERE~24.5, 23.2, 22.3 23.7, 22.3, 20.9
 삭제문(DELETE FROM~)
407403
215핵심 갱신문(UPDATE~ SET~)
407404
216핵심
데이터 조작문의 네 가지 유형
407431
217핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   62PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   62 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

63
정보처리기사 필기   핵심 요 약SELECT   [PREDICATE] [ 테이블명 .]속성명 [AS 별칭][, [테이블명 .]속
성명, …] 
[, 그룹함수 (속성명) [AS 별칭]]
[, Window 함수 OVER (PARTITION BY 속성명1, 속성명2, …
 ORDER BY 속성명3, 속성명4, …)]
FROM 테이블명 [, 테이블명 , …]
[WHERE  조건]
[GROUP BY 속성명, 속성명, …]
[HAVING 조건]
[ORDER BY  속성명 [ASC | DESC]];
•  SELECT절  
 -  PREDICATE  : 불러올 튜플 수를 제한할 명령어를 기
술함
  ▶  ALL : 모든 튜플을 검색할 때 지정하는 것으로, 
주로 생략함
  ▶  DISTINCT : 중복된 튜플이 있으면 그 중 첫 번째 
한 개만 검색함
  ▶  DISTINCTROW : 중복된 튜플을 제거하고 한 개
만 검색하지만 선택된 속성의 값이 아닌, 튜플 전
체를 대상으로 함
 -  속성명 : 검색하여 불러올 속성(열) 또는 속성을 이용
한 수식을 지정함
  ▶  기본 테이블을 구성하는 모든 속성을 지정할 때는 
‘ * ’를 기술함
  ▶  두 개 이상의 테이블을 대상으로 검색할 때는 ‘테
이블명.속성명’으로 표현함
 -  AS : 속성 및 연산의 이름을 다른 제목으로 표시하기 
위해 사용됨
•  FROM절  : 질의에 의해 검색될 데이터들을 포함하는 테
이블명을 기술함
• WHERE절  : 검색할 조건을 기술함
•  ORDER BY절  : 특정 속성을 기준으로 정렬하여 검색할 
때 사용함
 - 속성명 : 정렬의 기준이 되는 속성명을 기술함
 -   [ASC | DESC]  : 정렬 방식으로서 ‘ASC’는 오름차순, 
‘DESC’는 내림차순. 생략하면 오름차순으로 지정됨 <사원> <여가활동>
이름 부서 생일 주소 기본급 이름 취미 경력
홍길동 기획 04/05/61 망원동120 김선달 당구 10
임꺽정 인터넷 01/09/69 서교동80 성춘향나이트
댄스5
황진이 편집 07/21/75 합정동100 일지매 태껸 15
김선달 편집 10/22/73 망원동90 임꺽정 씨름 8
성춘향 기획 02/20/64 대흥동100
장길산 편집 03/11/67 상암동 120
일지매 기획 04/29/78 연남동110
강건달 인터넷 12/11/80 90
예제 1 <사원> 테이블에서 ‘주소’만 검색하되 같은 ‘주소’는 
한 번만 출력하시오. 
SELECT DISTINCT 주소
FROM 사원;
<결과>
주소
대흥동
망원동
상암동
서교동
연남동
합정동
예제 2 <사원> 테이블에서 “기획” 부서에 근무하면서 “대
흥동”에 사는 사람의 튜플을 검색하시오.
SELECT *
FROM 사원
WHERE 부서 = ‘기획’ AND 주소 = ‘대흥동’;
<결과>
이름 부서 생일 주소 기본급
성춘향 기획 02/20/64 대흥동10025.5, 25.2, 24.7, 22.4, 22.3, 21.5, 20.8, 20.6
SELECT 1 - 일반 형식
407501
218핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   63PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   63 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

64
정보처리기사 필기   핵심 요 약
조건 연산자
• 비교 연산자
연산자 의미
= 같다
< > 같지 않다
> 크다
< 작다
> = 크거나 같다
< = 작거나 같다
• 논리 연산자  : NOT, AND, OR
•  LIKE 연산자  : 대표 문자를 이용해 지정된 속성의 값이 문
자 패턴과 일치하는 튜플을 검색하기 위해 사용됨
대표 문자 의미
% 모든 문자를 대표함
_ 문자 하나를 대표함
# 숫자 하나를 대표함
연산자 우선순위
종류 연산자 우선순위
산술 연산자 ×, /, +, -왼쪽에서 오른쪽으로 갈수록 
낮아짐
관계 연산자 =, < >, >, >=, <, <= 모두 같음
논리 연산자 NOT, AND, OR왼쪽에서 오른쪽으로 갈수록 
낮아짐
※   산술, 관계, 논리 연산자가 함께 사용되었을 때는 산술 
> 관계 > 논리 연산자 순서로 연산자 우선순위가 정해
집니다. <사원> <여가활동>
이름 부서 생일 주소기본급 이름 취미 경력
홍길동 기획04/05/61 망원동120 김선달 당구 10
임꺽정 인터넷 01/09/69 서교동80 성춘향나이트
댄스5
황진이 편집 07/21/75 합정동100 일지매 태껸 15
김선달 편집 10/22/73 망원동90 임꺽정 씨름 8
성춘향 기획02/20/64 대흥동100
장길산 편집 03/11/67 상암동 120
일지매 기획04/29/78 연남동110
강건달 인터넷 12/11/80 90
예제 <사원> 테이블에서 성이 ‘김’인 사람의 튜플을 검색
하시오.
SELECT *
FROM 사원
WHERE 이름 LIKE “김%”;
<결과>
이름 부서 생일 주소 기본급
김선달 편집 10/22/73 망원동90
하위 질의는 조건절에 주어진 질의를 먼저 수행하여 그 검
색 결과를 조건절의 피연산자로 사용한다.
<사원> <여가활동>
이름 부서 생일 주소기본급 이름 취미 경력
홍길동 기획04/05/61 망원동120 김선달 당구 10
임꺽정 인터넷 01/09/69 서교동80 성춘향나이트
댄스5
황진이 편집 07/21/75 합정동100 일지매 태껸 15
김선달 편집 10/22/73 망원동90 임꺽정 씨름 8
성춘향 기획02/20/64 대흥동100
장길산 편집 03/11/67 상암동 120
일지매 기획04/29/78 연남동110
강건달 인터넷 12/11/80 9021.8
## 25.8, 24.7, 24.2, 23.5, 22.4, 21.3, 20.9, 20.6조건 연산자 / 연산자 우선순위
407531
219핵심
하위 질의
407505
220핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   64PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   64 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

65
정보처리기사 필기   핵심 요 약예제 1 ‘취미’가 “나이트댄스”인 사원의 ‘이름’과 ‘주소’를 
검색하시오. 
SELECT 이름, 주소
FROM 사원
WHERE 이름 =  (SELECT 이름 FROM 여가활동 WHERE 취미 = 
‘나이트댄스’) ;
<결과>
이름 주소
성춘향 대흥동
예제 2 취미활동을 하는 사원들의 부서를 검색하시오.
SELECT 부서 
FROM 사원 
WHERE EXISTS  (SELECT 이름 FROM 여가활동 WHERE 여가활
동.이름 = 사원.이름);
<결과>
부서
인터넷
편집
기획
기획
SELECT   [PREDICATE] [ 테이블명 .]속성명 [AS 별칭][, [테이블명 .]속
성명, …]
[, 그룹함수 (속성명) [AS 별칭]]
[, WINDOW 함수 OVER (PARTITION BY 속성명1, 속성명2, …
 ORDER BY 속성명3, 속성명4, …) [AS 별칭] ]
FROM 테이블명 [, 테이블명 , …]
[WHERE 조건]
[GROUP BY  속성명, 속성명, …]
[HAVING  조건]
[ORDER BY 속성명 [ASC | DESC]];•  그룹함수  : GROUP BY절에 지정된 그룹별로 속성의 값
을 집계할 함수를 기술함 
•  WINDOW 함수  : GROUP BY절을 이용하지 않고 속성의 
값을 집계할 함수를 기술함
 -  PARTITION BY  : WINDOW 함수가 적용될 범위로 사
용할 속성을 지정함
 -  ORDER BY : PARTITION 안에서 정렬 기준으로 사
용할 속성을 지정함
•  GROUP BY절  : 특정 속성을 기준으로 그룹화하여 검색
할 때 사용함. 일반적으로 GROUP BY절은 그룹 함수
와 함께 사용됨
•  HAVING절  : GROUP BY와 함께 사용되며, 그룹에 대한 
조건을 지정함
<상여금>
부서 이름 상여내역 상여금
기획 홍길동 연장근무 100
기획 일지매 연장근무 100
기획 최준호 야간근무 120
기획 장길산 특별근무 90
인터넷 강건달 특별근무 90
인터넷 서국현 특별근무 90
인터넷 박인식 연장근무 30
편집 김선달 특별근무 80
편집 황종근 연장근무 40
편집 성춘향 야간근무 80
편집 임꺽정 야간근무 80
편집 황진이 야간근무 50
예제 <상여금> 테이블에서 ‘상여금’이 100 이상인 사원
이 2명 이상인 ‘부서’의 튜플 수를 구하시오. 
SELECT 부서, COUNT( *) AS 사원수
FROM 상여금
WHERE 상여금 >= 100
GROUP BY 부서
HAVING COUNT( *) >= 2;
<결과>
부서 사원수
기획 325.2, 21.8
SELECT 2 - 일반 형식
407601
221핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   65PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   65 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

66
정보처리기사 필기   핵심 요 약
GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 때 
사용된다.
• COUNT(속성명)  : 그룹별 튜플 수를 구하는 함수
• SUM(속성명)  : 그룹별 합계를 구하는 함수
• AVG(속성명)  : 그룹별 평균을 구하는 함수
• MAX(속성명) : 그룹별 최대값을 구하는 함수
• MIN(속성명)  : 그룹별 최소값을 구하는 함수
• STDDEV(속성명)  : 그룹별 표준편차를 구하는 함수
• VARIANCE(속성명)  : 그룹별 분산을 구하는 함수
집합 연산자를 사용하여 2개 이상의 테이블의 데이터를 
하나로 통합한다.
표기 형식
SELECT  속성명1, 속성명2, …
FROM 테이블명
UNION  | UNION ALL  | INTERSECT  | EXCEPT
SELECT  속성명1, 속성명2, …
FROM 테이블명
[ORDER BY 속성명 [ASC | DESC]];
•  두 개의 SELECT문에 기술한 속성들은 개수와 데이터 
유형이 서로 동일해야 한다.
• 집합 연산자의 종류(통합 질의의 종류)
UNION• 두 SELECT문의 조회 결과를 통합하여 모두 출력
함
•중복된 행은 한 번만 출력함
UNION ALL•두 SELECT문의 조회 결과를 통합하여 모두 출력함
•중복된 행도 그대로 출력함
INTERSECT 두 SELECT문의 조회 결과 중 공통된 행만 출력함
EXCEPT첫 번째 SELECT문의 조회 결과에서 두 번째 SELECT
문의 조회 결과를 제외한 행을 출력함<사원> <직원>
사원 직급 사원 직급
김형석 대리 신원섭 이사
홍영선 과장 이성호 대리
류기선 부장 홍영선 과장
김현천 이사 류기선 부장
예제 1 <사원> 테이블과 <직원> 테이블을 통합하는 질의
문을 작성하시오. (단, 같은 레코드가 중복되어 나오지 않
게 하시오.)
SELECT *
FROM 사원
UNION
SELECT *
FROM 직원;
<결과>
사원 직급
김현천 이사
김형석 대리
류기선 부장
신원섭 이사
이성호 대리
홍영선 과장
예제 2 <사원> 테이블과 <직원> 테이블에 공통으로 존재
하는 레코드만 통합하는 질의문을 작성하시오.
SELECT *
FROM 사원
INTERSECT
SELECT *
FROM 직원;
<결과>
사원 직급
류기선 부장
홍영선 과장25.5, 24.7, 24.5, 23.5, 23.2, 22.3, 21.524.5, 20.8
집합 연산자를 이용한  
통합 질의
407604
223핵심그룹 함수
407631
222핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   66PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   66 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

67
정보처리기사 필기   핵심 요 약트리거는 데이터베이스 시스템에서 데이터의 삽입
(Insert), 갱신(Update), 삭제(Delete) 등의 이벤트
(Event)가 발생할 때마다 관련 작업이 자동으로 수행되는 
절차형 SQL이다.
•  트리거는 데이터베이스에 저장되며, 데이터 변경 및 무
결성 유지, 로그 메시지 출력 등의 목적으로 사용된다.
•  트리거의 구문에는 DCL(데이터 제어어)을 사용할 수 
없으며, DCL이 포함된 프로시저나 함수를 호출하는 경
우에도 오류가 발생한다.
•  트리거에 오류가 있는 경우 트리거가 처리하는 데이터
에도 영향을 미치므로 트리거를 생성할 때 세심한 주의
가 필요하다.INNER JOIN은 일반적으로 EQUI JOIN과 NON-EQUI 
JOIN으로 구분된다.
•  조건이 없는 INNER JOIN을 수행하면 CROSS JOIN
과 동일한 결과를 얻을 수 있다.
• EQUI JOIN
 -   EQUI JOIN은 JOIN 대상 테이블에서 공통 속성을 
기준으로 ‘=’(equal) 비교에 의해 같은 값을 가지는 
행을 연결하여 결과를 생성하는 JOIN 방법이다.
 -   WHERE절을 이용한 EQUI JOIN의 표기 형식 
SELECT  [테이블명 1.]속성명, [테이블명 2.]속성명, …
FROM 테이블명 1, 테이블명 2, …
WHERE  테이블명 1.속성명 = 테이블명 2.속성명;
 -   NATURAL JOIN절을 이용한 EQUI JOIN의 표기 
형식
SELECT  [테이블명 1.]속성명, [테이블명 2.]속성명, …
FROM 테이블명 1 NATURAL JOIN  테이블명 2;
 -   JOIN ~ USING절을 이용한 EQUI JOIN의 표기 형식
SELECT  [테이블명 1.]속성명, [테이블명 2.]속성명, …
FROM 테이블명 1 JOIN 테이블명 2 USING(속성명);
<학생> <학과> <성적등급>
학번이름학과
코드선배성적 학과코드 학과명 등급최저최고
15고길동 com 83 com 컴퓨터 A90100
16이순신 han 96 han 국어 B8089
17김선달 com 1595 eng 영어 C6079
19아무개 han1675 D059
37박치민 1755
예제 <학생> 테이블과 <학과> 테이블에서 ‘학과코드’ 값
이 같은 튜플을 JOIN하여 ‘학번’, ‘이름’, ‘학과코드’, ‘학과
명’을 출력하는 SQL문을 작성하시오. • SELECT 학번, 이름, 학생.학과코드, 학과명
 FROM 학생, 학과
 WHERE 학생.학과코드 = 학과.학과코드;
• SELECT 학번, 이름, 학생.학과코드, 학과명
 FROM 학생 NATURAL JOIN 학과;
• SELECT 학번, 이름, 학생.학과코드, 학과명
 FROM 학생 JOIN 학과 USING(학과코드);
<결과>
학번 이름 학과코드 학과명
15 고길동 com 컴퓨터
16 이순신 han 국어
17 김선달 com 컴퓨터
19 아무개 han 국어21.5
## 22.7, 20.6INNER JOIN
1412302
224핵심
트리거(Trigger)의 개요
2411501
225핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   67PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   67 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

68
정보처리기사 필기   핵심 요 약
 DBMS 접속 기술은 DBMS에 접근하기 위해 사용하는 
API 또는 API의 사용을 편리하게 도와주는 프레임워크 
등을 의미한다.
JDBC(Java DataBase Connectivity)
•  JDBC는 Java 언어로 다양한 종류의 데이터베이스에 
접속하고 SQL문을 수행할 때 사용되는 표준 API이다.
• 1997년 2월 썬 마이크로시스템에서 출시했다.
• 접속하려는 DBMS에 대한 드라이버가 필요하다. 
ODBC(Open DataBase Connectivity)
•  ODBC는 데이터베이스에 접근하기 위한 표준 개방형 
API로, 개발 언어에 관계없이 사용할 수 있다.
• 1992년 9월 마이크로소프트에서 출시했다.
•  ODBC도 접속하려는 DBMS에 맞는 드라이버가 필요하
지만, 접속하려는 DBMS의 인터페이스를 알지 못하더
라도 ODBC 문장을 사용하여 SQL을 작성하면 ODBC에 
포함된 드라이버 관리자가 해당 DBMS의 인터페이스에 
맞게 연결해 주므로 DBMS의 종류를 몰라도 된다.  
MyBatis
•  MyBatis는 JDBC 코드를 단순화하여 사용할 수 있는 
SQL Mapping 기반 오픈 소스 접속 프레임워크이다.
•  JDBC로 데이터베이스에 접속하려면 다양한 메소드를 
호출하고 해제해야 하는데, MyBatis는 이를 간소화 했
고 접속 기능을 더욱 강화하였다.
•  MyBatis는 SQL 문장을 분리하여 XML 파일을 만들고, 
Mapping을 통해 SQL을 실행한다.
•  MyBatis는 SQL을 거의 그대로 사용할 수 있어 SQL 
친화적인 국내 환경에 적합하여 많이 사용된다.
ORM은 객체지향 프로그래밍의 객체(Object)와 관계형 
데이터베이스(Relational Database)의 데이터를 연결
(Mapping)하는 기술을 의미한다.
•  ORM은 객체지향 프로그래밍에서 사용할 수 있는 가상
의 객체지향 데이터베이스를 만들어 프로그래밍 코드
와 데이터를 연결한다. •  ORM으로 생성된 가상의 객체지향 데이터베이스는 프
로그래밍 코드 또는 데이터베이스와 독립적이므로 재
사용 및 유지보수가 용이하다.
•  ORM은 SQL 코드를 직접 입력하지 않고 선언문이나 
할당 같은 부수적인 코드가 생략되기 때문에 직관적이
고 간단하게 데이터를 조작할 수 있다.
데이터 전환이란 운영 중인 기존 정보 시스템에 축적되
어 있는 데이터를 추출(Extraction)하여 새로 개발할 정
보 시스템에서 운영 가능하도록 변환(Transformation)한 
후, 적재(Loading)하는 일련의 과정을 말한다.
•  데이터 전환을 ETL(Extraction, Transformation, 
Load), 즉 추출, 변환, 적재 과정이라고 한다.
•  데이터 전환을 데이터 이행(Data Migration) 또는 데이
터 이관이라고도 한다.  
문쿼리 성능 최적화는 데이터 입·출력 애플리케이션의 성
능 향상을 위해 SQL 코드를 최적화하는 것이다.
•  쿼리 성능을 최적화하기 전에 성능 측정 도구인 APM
을 사용하여 최적화 할 쿼리를 선정해야 한다.
•  최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획
을 검토하고 SQL 코드와 인덱스를 재구성한다. 
※ RBO vs CBO
RBO(Rule Based Optimizer)는 규칙 기반 옵티마이저이
고, CBO(Cost Based Optimizer)는 비용 기반 옵티마이
저로서 다음과 같은 차이점이 있다. 
 RBO CBO
최적화 기준 규칙에 정의된 우선순위 액세스 비용
성능 기준 개발자의 SQL 숙련도 옵티마이저의 예측 성능
특징 실행 계획 예측이 쉬움성능 통계치 정보 활용, 
예측이 복잡함
고려사항개발자의 규칙 이해도, 
규칙의 효율성비용 산출 공식의 정확성 
 
ORM(Object - Relational 
Mapping)의 개요
2411901
227핵심DBMS 접속 기술
2411702
226핵심
쿼리 성능 최적화의 개요
2459931
228핵심
데이터 전환의 정의
2412101
229핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   68PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   68 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

69
정보처리기사 필기   핵심 요 약데이터 검증이란 원천 시스템의 데이터를 목적 시스템의 
데이터로 전환하는 과정이 정상적으로 수행되었는지 여부
를 확인하는 과정을 말한다.
•  데이터 전환 검증은 검증 방법과 검증 단계에 따라 분
류할 수 있다.배치 프로그램은 사용자와의 상호 작용 없이 여러 작업들
을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 
것을 의미한다.
•  배치 프로그램이 갖추어야 하는 필수 요소는 다음과 같다.
대용량 
데이터대량의 데이터를 가져오거나, 전달하거나, 계산하는 등
의 처리가 가능해야 함
자동화심각한 오류가 발생하는 상황을 제외하고는 사용자의 개
입 없이 수행되어야 함
견고성잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 
일 없이 수행되어야 함
안정성/
신뢰성오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 
있어야 함
성능다른 응용 프로그램의 수행을 방해하지 않아야 하고, 지
정된 시간 내에 처리가 완료되어야 함오류 데이터 정제는 오류 관리 목록의 각 항목을 분석하여 
원천 데이터를 정제하거나 전환 프로그램을 수정하는 것
이다.
오류 데이터 분석
•  오류 관리 목록의 오류 데이터를 분석하여 오류 상태, 
심각도, 해결 방안을 확인 및 기재한다.
• 상태
Open 오류가 보고만 되고 분석되지 않은 상태
Assigned오류의 영향 분석 및 수정을 위해 개발자에게 오류를 
전달한 상태
Fixed 개발자가 오류를 수정한 상태
Closed수정된 오류에 대해 테스트를 다시 했을 때 오류가 발
견되지 않은 상태
Deferred 오류 수정을 연기한 상태
Classified보고된 오류를 관련자들이 확인했을 때 오류가 아니라
고 확인된 상태 종류 데이터 타입 크기
문자 char 1Byte
부호없는 문자형 unsigned char 1Byte
정수short 2Byte
int 4Byte
long 4Byte
long long 8Byte
실수float 4Byte
double 8Byte
long double 8Byte25.5, 23.5, 23.2, 20.8 
 24.2, 20.8프로그래밍 언어 활용 4과목
C/C++의 데이터 타입 크기 및  
기억 범위
400102
233핵심데이터 검증
2412401
230핵심
오류 데이터 정제
2412504
231핵심배치 프로그램
2413001
232핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   69PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   69 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

70
정보처리기사 필기   핵심 요 약
배열이 자료의 형과 크기가 동일한 변수의 모임이라면 구
조체는 자료의 종류가 다른 변수의 모임이라고 할 수 있
다. 예를 들어 이름, 직위, 급여 등의 필드가 필요한 사원 
자료를 하나의 단위로 관리하려면 이름과 직위는 문자, 
급여는 숫자와 같이 문자와 숫자가 혼용되므로 배열로는 
처리할 수 없습니다. 이런 경우 구조체를 사용하면 간단
하게 처리할 수 있다.
•  구조체를 정의한다는 것은 int나 char 같은 자료형을 
하나 만드는 것을 의미한다.
•  구조체는 ‘structure(구조)’의 약어인 ‘struct’를 사용하
여 정의한다.
• 구조체 정의 예
struct sawon {
 char name[10];
 char position[10];
 int pay;
}
종류 데이터 타입 크기
문자 char 2Byte
정수byte 1Byte
short 2Byte
int 4Byte
long 8Byte
실수float 4Byte
double 8Byte
논리 boolean 1Byte시퀀스 자료형(Sequence Type)이란 리스트(List), 튜플
(Tuple), range, 문자열처럼 값이 연속적으로 이어진 자
료형을 말한다.
•  리스트(List)  : 다양한 자료형의 값을 연속적으로 저장하
며, 필요에 따라 개수를 늘리거나 줄일 수 있음
•  튜플(Tuple)  : 리스트처럼 요소를 연속적으로 저장하지
만, 요소의 추가, 삭제, 변경은 불가능함
•  range : 연속된 숫자를 생성하는 것으로, 리스트, 반복
문 등에서 많이 사용됨
변수의 개요 
변수(Variable)는 컴퓨터가 명령을 처리하는 도중 발생하
는 값을 저장하기 위한 공간으로, 변할 수 있는 값을 의미
한다.
•  변수는 저장하는 값에 따라 정수형, 실수형, 문자형, 포
인터형 등으로 구분한다. 
변수명 작성 규칙 
• 영문자, 숫자, _(under bar)를 사용할 수 있다.
•  첫 글자는 영문자나 _(under bar)로 시작해야 하며, 숫
자는 올 수 없다.
• 글자 수에 제한이 없다. 
• 공백이나 *, +, -, / 등의 특수문자를 사용할 수 없다. 
• 대·소문자를 구분한다. 
• 예약어를 변수명으로 사용할 수 없다. 
•  변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 
한다. 
•  변수 선언 시 변수명에 데이터 타입을 명시하는 것을 
헝가리안 표기법(Hungarian Notation)이라고 한다. 25.2, 23.2, 21.3, 20.925.8, 25.2, 24.7, 24.2, 23.7, 23.5, 21.8, 21.3, 20.8, 20.620.9 24.7, 23.7, 22.4
JAVA의 데이터 타입 크기 및  
기억 범위
400103
235핵심변수의 개요 /  
변수명 작성 규칙
400202
237핵심C언어의 구조체
400131
234핵심 Python의 시퀀스 자료형
2459955
236핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   70PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   70 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

71
정보처리기사 필기   핵심 요 약•  변수를 선언만 하고 사용하지 않으면 이 변수들이 점유
한 메모리 공간은 다른 프로그램들이 사용할 수 없게 
된다.
•  이렇게 선언만 하고 사용하지 않는 변수들이 점유한 메
모리 공간을 강제로 해제하여 다른 프로그램들이 사
용할 수 있도록 하는 것을 가비지 콜렉션(Garbage 
Collection)이라고 하며, 이 기능을 수행하는 모듈을 가
비지 콜렉터(Garbage Collector)라고 한다.
산술 연산자는 가, 감, 승, 제 등의 산술 계산에 사용되는 
연산자를 말한다.
•  산술 연산자에는 일반 산술식과 달리 한 변수의 값을 
증가하거나 감소시키는 증감 연산자가 있다. 
연산자 의미 비고
+ 덧셈
- 뺄셈
* 곱셈
/ 나눗셈
% 나머지
+ + 증가 연산자 전치 : 변수 앞에 증감 연산자가 오는 형
태로 먼저 변수의 값을 증감시킨 후 변수
를 연산에 사용함(++a, -  -a).
후치 : 변수 뒤에 증감 연산자가 오는 형
태로 먼저 변수를 연산에 사용한 후 변수
의 값을 증감시킴(a++, a-  -).-  - 감소 연산자관계 연산자는 두 수의 관계를 비교하여 참(true) 또는 거
짓(false)을 결과로 얻는 연산자이다. 
•  거짓은 0, 참은 1로 사용되지만 0외의 모든 숫자도 참
으로 간주된다.
연산자 의미
=  = 같다
!= 같지 않다
> 크다
>= 크거나 같다
%
< 작다
<= 작거나 같다
논리 연산자는 두 개의 논리 값을 연산하여 참(true) 또는 
거짓(false)을 결과로 얻는 연산자이다. 관계 연산자와 마
찬가지로 거짓은 0, 참은 1이다.
연산자 의미 비고
! not 부정
&& and 모두 참이면 참
|| or 하나라도 참이면 참25.5, 22.7, 21.8
## 25.8, 25.5, 25.2, 24.7, 24.2, 23.2, 21.5, 21.3, 20.925.2
비트 연산자는 비트별(0, 1)로 연산하여 결과를 얻는 연산
자이다.
연산자 의미 비고
& and 모든 비트가 1일 때만 1
^ xor 모든 비트가 같으면 0, 하나라도 다르면 1
| or 모든 비트 중 한 비트라도 1이면 1
~ not 각 비트의 부정, 0이면 1, 1이면 0
<< 왼쪽 시프트 비트를 왼쪽으로 이동
>> 오른쪽 시프트 비트를 오른쪽으로 이동24.2, 23.7, 23.5, 21.5, 20.6
## 25.8, 23.7, 23.5, 22.7, 22.4, 22.3가비지 콜렉터  
(Garbage Collector)
2413333
238핵심
산술 연산자 
400401
239핵심관계 연산자  
400402
240핵심
비트 연산자   
400403
241핵심
논리 연산자    
400404
242핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   71PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   71 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

72
정보처리기사 필기   핵심 요 약
연산 후 결과를 대입하는 연산식을 간략하게 입력할 수 있
도록 대입 연산자를 제공한다. 대입 연산자는 산술, 관계, 
비트, 논리 연산자에 모두 적용할 수 있다.
연산자 예 의미
+= a += 1 a = a + 1
-= a -= 1 a = a - 1
*= a *= 1 a = a * 1
/= a /= 1 a = a / 1
%= a %= 1 a = a % 1
<<= a <<= 1 a = a << 1
>>= a >>= 1 a = a >> 1
•  한 개의 수식에 여러 개의 연산자가 사용되면 기본적으
로 아래 표의 순서대로 처리된다.
•  아래 표의 한 줄에 가로로 나열된 연산자는 우선순위가 
같기 때문에 결합규칙에 따라 ←는 오른쪽에 있는 연산
자부터, →는 왼쪽에 있는 연산자부터 차례로 계산된다.대분류 중분류 연산자 결합규칙 우선 순위
단항 
연산자단항 
연산자!(논리 not)   ~(비트 not)   ++(증
가)  -  -(감소)  sizeof (기타)높음
이항 
연산자산술 
연산자*  /  % (나머지)
+  -
시프트 
연산자<<  >>
관계 
연산자<  <=  >=  >
=  =(같다)  !=(같지 않다)
비트 
연산자&(비트 and)
^(비트 xor)
|(비트 or)
논리 
연산자&&(논리 and)
||(논리 or)
삼항 
연산자조건 
연산자?  :
대입 
연산자대입 
연산자=  +=  -=  *=  /=  %=  
<<=  >>= 등
순서 
연산자순서 
연산자,낮음
scanf( ) 함수는 C언어의 표준 입력 함수로, 키보드로 입
력받아 변수에 저장하는 함수이다.
형식
scanf (서식 문자열, 
변수의 주소)• 서식 문자열 : 입력받을 데이터의 자료
형을 지정함
• 변수의 주소 : 데이터를 입력받을 변수
를 적는다. 변수의 주소로 입력받아야 
하기 때문에 변수에 주소연산자 &를 
붙임
  scanf(" %3d ", &a);
 ▶ % : 서식 문자임을 지정
 ▶ 3 : 입력 자릿수를 3자리로 지정
 ▶ d : 10진수로 입력
 ▶ &a : 입력받은 데이터를 변수 a의 주소에 저장  
조건 연산자는 조건에 따라 서로 다른 수식을 수행한다.
• 형식
조건 ? 수식1 : 수식2;   
•  ‘조건’의 수식이 참이면 ‘수식1’을, 거짓이면 ‘수식2’를 실
행한다.25.5, 22.4, 20.8
## 25.2, 24.7, 22.3, 21.8, 21.525.5, 23.2대입 연산자
400405
243핵심
조건 연산자
400406
244핵심
연산자 우선순위
400408
245핵심scanf( ) 함수
2459932
246핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   72PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   72 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

73
정보처리기사 필기   핵심 요 약특징
•  입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있다.
• 한 번에 여러 개의 데이터를 입력 받을 수 있다.
• 서식 문자열과 변수의 자료형은 일치해야 한다.
    scanf("%d  %f", &i, &j); → ‘%d’와 i, “%f”와 j는 자
료형이 일치해야 한다.
printf( ) 함수는 C언어의 표준 출력 함수로, 인수로 주어
진 값을 화면에 출력하는 함수이다.
형식
printf(서식 문자열, 
변수)• 서식 문자열 : 변수의 자료형에 맞는 서
식 문자열을 입력함
• 변수 : 서식 문자열의 순서에 맞게 출력
할 변수를 적음. scanf( )와 달리 주소 연
산자 &를 붙이지 않음  printf("%-8.2f", 200.2);   
(∨는 빈 칸을 의미함)
## 200.20V V
 ▶ % : 서식 문자임을 지정
 ▶ - : 왼쪽부터 출력
 ▶ 8 : 출력 자릿수를 8자리로 지정
 ▶ 2 : 소수점 이하를 2자리로 지정
 ▶ f : 실수로 출력
•  JAVA에서 값을 화면에 출력할 때는 System 클래스의 
서브 클래스인 out 클래스의 메소드 print( ), println( ), 
printf( ) 등을 사용하여 출력한다.
• 형식 1 : 서식 문자열에 맞게 변수의 내용을 출력함
System.out.printf (서식 문자열, 변수)
 -  printf( ) 메소드는 C언어의 printf( ) 함수와 사용법
이 동일하다. 서식 문자열 의미
%d 정수형 10진수를 입·출력하기 위해 지정함
%u 부호없는 정수형 10진수를 입·출력하기 위해 지정함
%o 정수형 8진수를 입·출력하기 위해 지정함
%x 정수형 16진수를 입·출력하기 위해 지정함
%c 문자를 입·출력하기 위해 지정함
%s 문자열을 입·출력하기 위해 지정함
%f 소수점을 포함하는 실수를 입·출력하기 위해 지정함
%e 지수형 실수를 입·출력하기 위해 지정함
%ld long형 10진수를 입·출력하기 위해 지정함
%lo long형 8진수를 입·출력하기 위해 지정함
%lx long형 16진수를 입·출력하기 위해 지정함
%p 주소를 16진수로 입·출력하기 위해 지정함 
## 22.7, 22.4, 22.3, 21.8, 21.5, 20.8문자 의미 기능
\n new line 커서를 다음 줄 앞으로 이동함
\b backspace 커서를 왼쪽으로 한 칸 이동함
\t tab 커서를 일정 간격 띄움
\r carriage return 커서를 현재 줄의 처음으로 이동함
\0 null 널 문자를 출력함
\' single quote 작은따옴표를 출력함
\" double quote 큰따옴표를 출력함
\a alert 스피커로 벨 소리를 출력함
\\ backslash 역 슬래시를 출력함
\f form feed 한 페이지를 넘김22.7, 22.4, 22.3, 21.8, 21.5, 20.8
## 24.5, 21.3, 20.9서식 문자열
2459933
247핵심
printf( ) 함수
2459934
248핵심주요 제어문자
2459935
249핵심
JAVA에서의 표준 출력
400333
250핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   73PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   73 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

74
정보처리기사 필기   핵심 요 약
   System.out.printf(“%-8.2f”, 200.2);   
(V는 빈 칸을 의미함)
## 200.20V V
 ▶ % : 서식 문자임을 지정
 ▶ - : 왼쪽부터 출력
 ▶ 8 : 출력 자릿수를 8자리로 지정
 ▶ 2 : 소수점 이하를 2자리로 지정
 ▶ f : 실수로 출력
• 형식 2 : 값이나 변수의 내용을 형식없이 출력함
System.out.print( )
 - 문자열을 출력할 때는 큰따옴표로 묶어줘야 한다.
 -  문자열 또는 문자열 변수를 연속으로 출력할 때는 +
를 이용한다.
  System.out.print(“abc123” + “def”);
abc123def                         
•  형식 3 : 값이나 변수의 내용을 형식없이 출력한 후 커
서를 다음 줄의 처음으로 이동함
System.out.println( )
 -  println( ) 메소드는 출력 후 다음 줄로 이동한다는 
것을 제외하면 print( ) 메소드와 사용법이 동일하다.
  System.out.print(“abc123” + “def”);
abc123def
|
커서의 위치
if문은 조건에 따라서 실행할 문장을 달리하는 제어문이
며, 단순 if문은 조건이 한 개 일 때 사용하는 제어문이다. 
•  조건이 참일 때만 실행할 문장을 지정할 수도 있고, 참
과 거짓에 대해 각각 다른 실행문을 지정할 수도 있다. 
• 형식1 : 조건이 참일 때만 실행함
 -   조건이 참일 때 실행할 문장이 하나인 경우
if(조건)
	if는 조건 판단문에  사용되는  예약어이므로  그대로 
적는다.
조건은 참(1) 또는 거짓(0)이 결과로 나올 수 있는 수
식을 ( ) 안에 입력한다 .
	실행할	문장; 	조건이 참일 경우 실행할 문장을 적는다. -   조건이 참일 때 실행할 문장이 두 문장 이상인 경우
if(조건)	
{	
	실행할	문장1; 	 { } 사이에 조건이 참일 경우 실행할 문장을 적는다.
	실행할	문장2;
	 							⋮
}
예제 1  a가 10보다 크면 a에서 10을 빼기
#include	<stdio.h>
main(	)
{	
	int	a	=	15,	b;
	if	(a	>	10)	 ❶	 a가 10보다 크면 ❷번 문장을 실행하고 , 아니면 
❸번 문장으로  이동해서  실행을 계속한다 .
	 	b	=	a	–	10;	 ❷	 ❶번의 조건식이  참일 경우 실행할 문장이
다. b는 5가 된다.
	printf(“%d \n”,	b);	 ❸
	여기서는  ❶번의 조건식이  거짓일 경
우 실행할 문장이 없다. 조건 판단문
을 벗어나면  무조건 ❸번으로 온다.
결과5
• 형식2 : 조건이 참일 때와 거짓 때 실행할 문장이 다름
if(조건)	
	실행할	문장1;
	 조건이 참일 경우 실행할 문장을 적는다. 참일 경
우 실행할 문장이 두 문장 이상이면  { }를 입력하
고 그 사이에 문장을 적는다.
else
	실행할	문장2;	조건이 거짓일 경우 실행할 문장을 적는다. 두 문장 
이상인 경우 { }를 입력하고  그 사이에 문장을 적는다.
예제 2  a가 b보다 크면 ‘a-b’, 아니면 ‘b-a’를 수행하기
#include	<stdio.h>
main(	)
{	
	int	a	=	10,	b	=	20,	cha;
	if	(a	>	b)	 ❶	 a가 b보다 크면 ❷번 문장을 실행하고 , 아니면 
❸번의 다음 문장인 ❹번 문장을 실행한다 .
	 	cha	=	a	–	b;	 ❷
	❶번의 조건식이  참일 경우 실행할 문장이
다. 참이 아니기 때문에 초기화 시키지 않
은 cha에는 알 수 없는 값이 그대로 있게 
된다.
	else	❸	❶번의 조건식이  거짓일 경우 실행할 문장
의 시작점이다 . 
	 	cha	=	b	–	a;	 ❹
	❶번의 조건식이  거짓일 경우 실행할 실제 
처리문이다 . cha는 10이 된다. 
	printf(“%d \n”,	cha);	결과10
}22.3, 21.5
단순 if문
400502
251핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   74PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   74 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

75
정보처리기사 필기   핵심 요 약• 형식2 : if문 안에 if문이 포함된다.
if(조건1)	
			{  조건1이 참일 경우 실행할 문장의 시작 점
이다.
					if(조건2)
							실행할	문장1;  조건2가 참일 경우 실행할 문장 을 적는다.
					else
							실행할	문장2;  조건2가 거짓일 경우 실행할 문장 을 적는다.
			}
else
			실행할	문장3;  조건1이 거짓일 경우 실행할 문장 을 적는다 .
예제 2  홀수, 짝수 판별하기
#include	<stdio.h>
main(	)
{
		int	a	=	21,	b	=	10;
		if	(a	%	2	==	0)	 ❶  a를 2로 나눈 나머지가  0이면 ❷번을 
실행하고 , 아니면 ❻번으로 이동한다 .
					if	(b	%	2	==	0)	 ❷  b를 2로 나눈 나머지가  0이면 ❸번
을 실행하고 , 아니면 ❹번으로 이동
한다.
							printf("모두	짝수 \n");	❸ “모두 짝수”를 출력하
고, 번으로 이동하여  
프로그램을  종료한다 .
					else	 ❹  ❷번의 조건식이  거짓일 경우 ❺번을 
실행한다 .
									printf("a	:	짝수,	b	:	홀수 \n");	❺
  “a : 짝수, b : 홀수”를  출력하고 , 번으로 이동하여  프로그램을  종료한다 .
		else	 ❻  ❶번의 조건식이  거짓일 경우 실행할 
문장의 시작점이다.
					if	(b	%	2	==	0)	 ❼  b를 2로 나눈 나머지가  0이면 ❽번
을 실행하고 , 아니면 ❾번으로 이동
한다.
							printf("a	:	홀수,	b	:	짝수 \n");	❽
  “a : 홀수, b : 짝수”를 출력하고 , 번으로 이동하여  프로그램을  종료한다 .
					else	 ❾  ❼번의 조건식이  거짓일 경우 실행할 
문장의 시작점이다.
							printf("모두	홀수 \n");	❿  “모두 홀수”를  출력하
고, 번으로 이동하여  
프로그램을  종료한다 .
}	  
결과a : 홀수, b : 짝수다중 if문은 조건이 여러 개 일 때 사용하는 제어문이다. 
• 형식1 
if(조건1)	
			실행할	문장1;  조건1이 참 일 경우  실행할 문장 을 적는다.
else	if(조건2)
			실행할	문장2;  조건2가 참 일 경우  실행할 문장 을 적는다.
else	if(조건3)
			실행할	문장3;  조건3이 참 일 경우  실행할 문장 을 적는다.
										⋮
else
			실행할	문장4;  앞의 조건이 모두 거짓 일 경우  실행할 문장 을 
적는다.
예제 1  점수에 따라 등급 표시하기
#include	<stdio.h>
main(	)
{	
		int	jum	=	85;
		if	(jum	>=	90)	 ❶  jum이 90 이상이면 ❷번을 
실행하고, 아니면 ❸번으
로 이동한다.
				printf("학점은	A입니다. \n");	❷ “학점은 A입니
다.”를 출력하
고, ❾번으로 이
동하여 프로그
램을 종료한다.
		else	if	(jum	>=	80)	 ❸  jum이 80 이상이면 ❹번을 
실행하고, 아니면 ❺번으
로 이동한다.
				printf("학점은	B입니다. \n");	❹  “학점은 B입니
다.”를 출력하
고, ❾번으로 이
동하여 프로그
램을 종료한다.
		else	if	(jum	>=	70)	 ❺  jum이 70 이상이면 ❻번을 
실행하고, 아니면 ❼번으
로 이동한다.
				printf("학점은	C입니다. \n");	❻ “학점은 C입니다.”
를 출력하고, ❾번
으로 이동하여 프로
그램을 종료한다. 
		else	 ❼  ❺번의 조건식이 거짓일 
경우 ❽번을 실행한다.
				printf("학점은	F입니다. \n");	❽  “학점은 F입니다.”
를 출력하고, ❾번
으로 이동하여 프
로그램을 종료한다.
}	❾  
결과학점은 B입니다.24.5, 22.4, 22.3, 21.5, 20.8
다중 if문
400503
252핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   75PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   75 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

76
정보처리기사 필기   핵심 요 약
switch문은 조건에 따라 분기할 곳이 여러 곳인 경우 간
단하게 처리할 수 있는 제어문이다.
• 형식
switch(수식)	 ❶
	 • switch는 switch 문에 사용되는  예약어로  그대로 
입력한다 . 
• 수식 : ‘레이블1’ ~ ‘레이블n’의 값 중 하나를 도
출하는 변수나 수식을 입력한다 . 
{	❷	 ❷~❺번이 switch문의 범위이다 . ‘{’로 시작해서  ‘}’
로 끝난다. 반드시 입력해야  한다.
	case	레이블1:	 ❸
	• case는 switch 문에서 레이블을  지정하기  
위한 예약어로  그대로 입력해야  한다.
• 레이블1 : ❶번 식의 결과가 될 만한 값 중 
하나를 입력한다 . 결과가 ‘레이블1’과 일치
하면 이곳으로  찾아온다 . 식의 결과가 5종
류로 나타나면  case문이 5번 나와야한다 .
		실행할	문장1;	❶번 식의 결과가 ❸번의 ‘레이블1’과 일치할 
때 실행할 문장이다 .
	 	break;	  switch문을 탈출하여  ❺번으로 간다. 
	case	레이블2:	 ❹
	 ❶번의 식의 결과가 ‘레이블2’와 일치하면 찾
아오는 곳이다. 
		실행할	문장2;	 ❶번의 식의 결과가 ❹번의 ‘레이블2’와 일치
할 때 실행할 문장이다.
	 	break;	 switch문을 탈출하여 ❺번으로 간다.
			⋮
	default	❶번의 식의 결과가 ‘레이블1’ ~ ‘레이블n’에 
해당하지 않는 경우 찾아오는 곳이다.
	 	실행할	문장3;
}	❺
•  case문의 레이블에는 한 개의 상수만 지정할 수 있으
며, int, char, enum형의 상수만 가능하다.
• case문의 레이블에는 변수를 지정할 수 없다.
•  break문은 생략이 가능하지만 break문이 생략되면 수
식과 레이블이 일치할 때 실행할 문장부터 break문 또
는 switch문이 종료될 때까지 모든 문장이 실행된다.  
예제  점수(jum)에 따라 등급 표시하기
#include	<stdio.h>
main(	)
{
		int	jum	=	85;
		switch	(jum	/	10)		switch(수식)	
	 jum을 10으로 나눠 결과에 해당하는 숫자를 찾아
간다. 85/10은 8.5지만 C 언어에서 정수 나눗셈은 
결과도 정수이므로 결과는 8이다. 8에 해당하는 ❺
번으로 이동하여 ❻, ❼번을 실행한다. 
		{	❶	  ❶~❽번까지가 switch 조건문의 범위이다.
	 		case	10:
	 100점일 경우 ‘jum/10’의 결과인 10이 찾아오는 곳
이지만 할 일은 ‘case 9:’와 같으므로 아무것도 적
지 않는다. 아무것도 적지 않으면 다음 문장인 ❷
번으로 이동한다. 
	 		case	9:	 ❷
	 ‘jum/10’이 9일 경우 찾아오는 곳이다. ❸, ❹번을 
실행한다.
	 	 	printf(“학점은	A입니다. \n”);	❸
	  “학점은 A입니다.”를 출력한다.
	 	 	break;	 ❹
	 break를 만나면 switch문을 탈출하여 ❾번으로 이
동한다. 
	 		case	8:	 ❺
	‘jum/10’이 8일 경우 찾아오는 곳이다. ❻, ❼번을 
실행한다. 
	 	 	printf(“학점은	B입니다. \n”);	❻
	 “학점은 B입니다.”를 출력한다. 
	 	 	break;	 ❼	 switch문을 탈출하여 ❾번으로 이동한다. 
	 		case	7:	
	 	 	printf(“학점은	C입니다. \n”);
	 	 	break;
	 		case	6:
	 	 	printf(“학점은	D입니다. \n”);
	 	 	break;
	 		default:	 case 10~6에 해당되지 않는 경우, 즉 jum이 59 
이하인 경우 찾아오는 곳이다. 
	 	 	printf(“학점은	F입니다. \n”);
	  “학점은 F입니다.”를 출력한다.
	 		}	 ❽
}	❾	결과학점은 B입니다.
 for문은 초기값, 최종값, 증가값을 지정하는 수식을 이용
해 정해진 횟수를 반복하는 제어문이다.
•  for문은 초기값을 정한 다음 최종값에 대한 조건이 참
이면 실행할 문장을 실행한 후 초기값을 증가값 만큼 
증가시키면서 최종값에 대한 조건이 참인 동안 실행할 
문장을 반복 수행한다.  25.8, 22.7
## 24.7, 24.2, 23.2, 22.7, 22.4, 22.3, 21.5, 20.8switch문
400504
253핵심
for문
400602
254핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   76PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   76 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

77
정보처리기사 필기   핵심 요 약while문은 조건이 참인 동안 실행할 문장을 반복 수행하
는 제어문이다.
•  while문은 조건이 참인동안 실행할 문장을 반복 수행하
다가 조건이 거짓이면 while문을 끝낸 후 다음 코드를 
실행한다.
•  while문은 조건이 처음부터 거짓이면 한 번도 수행하지 
않는다.
while문의 동작 과정조건 다음 코드 실행할 문장거짓
참
• 형식
while(조건)
	• while은 반복문에 사용되는 예약어로 그대로 입력
한다. 
• (조건) : 참이나 거짓을 결과로 갖는 수식을 ‘조건’
에 입력한다. 참(1)을 직접 입력할 수도 있다.
	실행할	문장;
	조건이 참인 동안 실행할 문장을 입력한다. 문
장이 두 문장 이상인 경우 { }를 입력하고 그 
사이에 처리할 문장들을 입력한다.for문의 동작 과정초기값
증가값실행할
문장최종값
조건식다음 코드거짓
참
• 형식
for(식1;	식2;	식3)
	• for는 반복문을 의미하는 예약어로 그대로 
입력한다. 
•식1 : 초기값을 지정할 수식을 입력한다. 
•식2 : 최종값을 지정할 수식을 입력한다. 
•식3 : 증가값으로 사용할 수식을 입력한다. 
	실행할	문장;
	식2가 참일 동안 실행할 문장을 입력한다. 실
행할 문장이 두 문장 이상일 경우 { }를 입력
하고 그 사이에 처리할 문장들을 입력한다.
•  for문은 처음부터 최종값에 대한 조건식을 만족하지 못
하면 한 번도 수행하지 않는다.예제  다음은 1~5까지의 합을 더하는 프로그램이다. 결
과를 확인하시오.
#include	<stdio.h>	
main(	)	
{	
	int	a	=	0,	hap	=	0;	
	while	(a	<	5)	 ❶
	 a가 5보다 작은 동안 ❷~❺번 문장을 반복하
여 수행한다. 
	{	❷
	❷~❺번까지가 반복문의 범위이다. 반복문에
서 실행할 문장이 하나인 경우는 {　}를 생략
해도 된다.
	 	a++;	 ❸	 ‘a = a + 1;’과 동일하다. a의 값을 1씩 증가시
킨다. 
	 	hap	+=	a;	 ❹
	‘hap = hap + a’와 동일하다. a의 값을 hap에 
누적시킨다.
	}	❺	 반복문의 끝이다.
	printf(“%d,	%d \n”,	a,	hap);	 ❻
	 결과5, 15
}
	a가 5가 되었을 때 5를 hap에 누적한 다음 
while 문을 벗어나기 때문에 a는 5로 끝난다. 
do~while문은 조건이 참인 동안 정해진 문장을 반복 수
행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 
같은 동작을 하는데, 다른 점은 do~while문은 실행할 문
장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여
부를 결정한다는 것이다.
•  do~while문은 실행할 문장을 우선 실행한 후 조건을 
판별하여 조건이 참이면 실행할 문장을 계속 반복 수행
하고, 거짓이면 do~while문을 끝낸 후 다음 코드를 실
행한다.
do~while문의 동작 과정실행할 문장 다음 코드 조건참 거짓
• 형식
do	do는 do~while문에 사용되는 예약어로, do~while
의 시작 부분에 그대로 입력한다. 
	실행할	문장;
	조건이 참인 동안 실행할 문장을 입력한다. 문장이 
두 문장 이상인 경우 { }를 입력하고 그 사이에 실행
할 문장들을 입력한다.
while(조건);
	• while은 do~while문에 사용되는 예약어로, 
do~while의 끝 부분에 그대로 입력한다. 
• (조건) : 참이나 거짓을 결과로 갖는 수식을 ‘조건’
에 입력한다. 참(1)을 직접 입력할 수도 있다.23.7, 23.2, 22.3, 21.8, 21.5, 21.3, 20.924.2, 23.7, 23.2, 21.5
while문
400603
255핵심do~while문
400604
256핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   77PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   77 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

78
정보처리기사 필기   핵심 요 약
switch문이나 반복문의 실행을 제어하기 위해 사용되는 
예약어이다.
•  break : switch문이나 반복문 안에서 break가 나오면 
블록을 벗어난다. 
•  continue
 -   continue 이후의 문장을 실행하지 않고 제어를 반복
문의 처음으로 옮긴다. 
 -   반복문에서만 사용된다.  예제  다음은 1부터 10까지 홀수의 합을 더하는 프로그
램이다. 결과를 확인하시오. 
#include	<stdio.h>	
main(	)	
{	
	int	a	=	1,	hap	=	0;	
	do	❶	do~while 반복문의 시작점이다. ❷~❺번 사
이의 문장을 반복하여 수행한다. 
	{	❷	  ❷~❺번까지가 반복문의 범위이다. 
	 	hap	+=	a;	 ❸	 ‘hap = hap + a’와 동일하다. a의 값을 hap에 
누적시킨다.
	 	a	+=	2;	 ❹	‘a = a + 2;’와 동일하다. a의 값을 2씩 증가시
킨다. 
	}	while(a	<	10); 	❺	a가 10보다 작은 동안 ❷~❺번 사이
의 문장을 반복하여 수행한다. 
	printf(“%d,	%d \n”,	a,	hap);		 ❻
	 결과11, 25
	a가 9가 되었을 때 9를 hap에 누적한 다음 a
에 2를 더해 a가 11이 되었을 때 do~while문
을 벗어나기 때문에 a는 11로 끝난다.
}예제  다음은 1~5까지의 합을 더하되 2의 배수는 배제
하는 프로그램이다. 결과를 확인하시오.
#include	<stdio.h>	
	main(	)
	{
					int	a	=	0,	hap	=	0;				
					while(1)	 ❶  조건이 참(1)이므로 무한 반복한
다. 중간에 반복을 끝내는 문장
이 반드시 있어야 한다. 
					{	 ❷  ❷~❾번까지가 반복문의 범위
이다. 
									a++;	 ❸  ‘a = a + 1;’과 동일하다. a의 값
을 1씩 증가시킨다. 
									if(a	>	5)	 ❹  a가 5보다 크면 ❺번 문장을 
수행하고, 아니면 ❻번 문장을 
수행한다.
												break;	 ❺  반복문을 탈출하여 ❿번으로 
이동한다.  
									if	(a	%	2	==	0)	 ❻  a를 2로 나눈 나머지가 0이면, 
즉 a가 2의 배수이면 ❼번 문
장을 수행하고, 아니면 ❽번 
문장으로 이동한다.  
												continue;	 ❼  이후의 문장, 즉 ❽번을 생략
하고 반복문의 처음인 ❶번으
로 이동한다. 2의 배수는 hap
에 누적되지 않는다. 
									hap	+=	a;	 ❽  ‘hap = hap + a’와 동일하다. 
a의 값을 hap에 누적시킨다.
					}	 ❾  반복문의 끝이다.
					printf("%d,	%d \n",	a,	hap);	 ❿
결과6, 9
	}
배열의 개념
배열은 동일한 데이터 유형을 여러 개 사용해야 할 경우 
이를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 
하나의 이름으로 정의해 사용하는 것을 말한다. 
•  배열은 하나의 이름으로 여러 기억장소를 가리키기 때
문에 배열에서 개별적인 요소들의 위치는 첨자를 이용
하여 지정한다. 
•  배열은 변수명 뒤에 대괄호 [ ]를 붙이고 그 안에 사용
할 개수를 지정한다.
• C언어에서 배열의 위치는 0부터 시작된다. 
• 배열은 행 우선으로 데이터가 기억장소에 할당된다.24.2, 23.5, 22.7, 22.325.5, 23.7, 22.4, 22.3, 21.8
break, continue 
400605
257핵심배열
400702
258핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   78PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   78 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

79
정보처리기사 필기   핵심 요 약•  C 언어에서 배열 위치를 나타내는 첨자 없이 배열 이
름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 
것과 같다.  
1차원 배열
•  1차원 배열은 변수들을 일직선상의 개념으로 조합한 배
열이다. 
• 형식
자료형 변수명
[개수];•자료형 : 배열에 저장할 자료의 형을 지정함
• 변수명 : 사용할 배열의 이름 으로 사용자가 임
의로 지정함
• 개수 : 배열의 크기를 지정하는 것으로 생략할 
수 있음
  int a[5] : 5개의 요소를 갖는 정수형 배열 a
첫 번째 두 번째 세 번째 네 번째 다섯 번째
배열 a a[0] a[1] a[2] a[3] a[4]
※  a[3] : a는 배열의 이름이고, 3은 첨자로서 배열 a에서
의 위치를 나타냄. a[3]에 4를 저장시키려면 ‘a[3] = 4’
와 같이 작성함
예제 1  1차원 배열 a의 각 요소에 10, 11, 12, 13, 14를 저
장한 후 출력하기
#include	<stdio.h>	
main(	)	
{	
	int	a[5];	
	5개의 요소를 갖는 정수형 배열 a를 선언한다. 선언할 때는 
사용할 개수를 선언하고, 사용할 때는 첨자를 0부터 사용하
므로 주의해야 한다. 
	첫 번째 두 번째 세 번째 네 번째 다섯 번째
배열 a a[0] a[1] a[2] a[3] a[4]
	int	i;		정수형 변수 i를 선언한다 
	for	(i	=	0;	i	<	5;	i++)
	 반복 변수 i가 0에서 시작하여 1씩 증가하면서 5보다 작은 동
안 ❶번 문장을 반복하여 수행한다. 그러니까 ❶번 문장을 5
회 반복하는 것이다.  
	 	a[i]	=	i	+	10;	 ❶
	배열 a의 i번째에 i+10을 저장시킨다. i는 0~4까지 변하므로 
배열 a에 저장된 값은 다음과 같다.  
	배열 a 10 11 12 13 14
a[0] a[1] a[2] a[3] a[4]
	for	(i	=	0;	i	<	5;	i++)
	반복 변수 i가 0에서 시작하여 1씩 증가하면서 5보다 작은 동
안 ❷번 문장을 반복하여 수행한다.
	 	printf(“%d	“,	a[i]);	 ❷
	배열 a의 i번째를 출력한다. i는 0~4까지 변하므로 출력 결과
는 다음과 같다. 서식 문자열에 ‘ \n’이 없기 때문에 한 줄에 
붙여서 출력한다. 
}	 결과 10 11 12 13 14•  2차원 배열은 변수들을 평면, 즉 행과 열로 조합한 배
열이다.
• 형식
자료형 변수명
[행개수][열개수]•자료형 : 배열에 저장할 자료의 형을 지정함
• 변수명 : 사용할 배열의 이름으로 사용자가 
임의로 지정함
•행개수 : 배열의 행 크기를 지정함
•열개수 : 배열의 열 크기를 지정함
  int b[3][3] : 3개의 행과 3개의 열을 갖는 정수형 배열 b
배열 b
열
행0, 0 0, 1 0, 2 b[0][2]
1, 0 1, 1 1, 2
2, 0 2, 1 2, 2
  b[0][2] : b는 배열의 이름이고, 0은 행 첨자, 2는 열 첨자로서 배열 
b에서의 위치를 나타낸다.
예제  3행 4열의 배열에 다음과 같이 숫자 저장하기 
배열 a
1 2 3 4
5 6 7 8
9 10 11 12
#include	<stdio.h>	
main(	)	
{	
	int	a[3][4]; 	 3행 4열의 크기를 갖는 정수형 배열 a를 선언한다.
	int	i,	j,	k	=	0;	 	정수형 변수 i를 선언한다 
	for	(i	=	0;	i	<	3;	i++)	 ❶
	반복 변수 i가 0에서 시작하여 1씩 증가하면서 3보다 작
은 동안 ❷~❽번을 반복하여 수행한다. 결국 ❸번 문
장을 3회 반복한다. 
	{	❷	❷~❽이 ❶번 반복문의 반복 범위이지만 실제 실행할 
문장은 ❸번 하나이다. 
	 	for	(j	=	0;	j	<	4;	j++)	 ❸
	반복 변수 j가 0에서 시작하여 1씩 증가하면서  
4보다 작은 동안 ❹~❼번을 반복하여 수행한다. 
•i가 0일 때 j는 0에서 3까지 4회 반복 
•i가 1일 때 j는 0에서 3까지 4회 반복 
• i가 2일 때 j는 0에서 3까지 4회 반복 수행하므로  
❺~❻번을 총 12회 수행한다.22.3, 21.5
2차원 배열
400703
259핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   79PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   79 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

80
정보처리기사 필기   핵심 요 약
		{	❹	❹~❼이 ❸번 반복문의 반복 범위이다. 
	 	 	k++;	 ❺
	 k를 1씩 증가시킨다. k는 총 12회 증가하므로 
1~12까지 변한다.
	 	 	a[i][j]	=	k;	 ❻
	배열 a의 i행 j열에 k를 기억시킨다. 
a[0][0]~a[2][3]까지 1~12가 저장된다.
		}	❼	❹번의 짝이다.
	}	❽	❹번의 ❷번의 짝이다..
}		첫 번째  { 의 짝이자 프로그램의 끝이다. 
• 배열 선언 시 초기값을 지정할 수 있다.
•  배열을 선언할 때 배열의 크기를 생략하는 경우에는 반
드시 초기값을 지정해야 초기값을 지정한 개수 만큼의 
배열이 선언된다.
   1차원 배열 초기화
  방법 1  char a[3] = {'A', 'B', 'C'}
  방법 2  char a[ ] = {'A', 'B', 'C'}
 배열 a A B C
 a[0] a[1] a[2]
   2차원 배열 초기화
  방법 1   int a[2][4] = { {10, 20, 30, 40}, {50, 60, 
70, 80} };
  방법 2   int a[2][4] = {10, 20, 30, 40, 50, 60, 70, 
80}
 a[0][0] a[0][1] a[0][2] a[0][3]
배열 a10 20 30 40
50 60 70 80
 a[1][0] a[1][1] a[1][2] a[1][3]
•  배열의 개수보다 적은 수로 배열을 초기화하면 입력된 
값만큼 지정한 숫자가 입력되고, 나머지 요소에는 0이 
입력된다.
   int a[5] = { 3, }; 또는 int a[5] = { 3 };
배열 a 3 0 0 0 0
a[0] a[1] a[2] a[3] a[4]C언어에서는 큰따옴표(“ ”)로 묶인 글자는 글자 수에 관계
없이 문자열로 처리된다.
•  C언어에는 문자열을 저장하는 자료형이 없기 때문에 
배열, 또는 포인터를 이용하여 처리한다.
•  형 식
char 배열이름[크기] = “문자열”
•  배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 
널 문자(‘\0’)가 문자열 끝에 자동으로 삽입된다.
•  배열에 문자열을 저장할 때는 배열 선언 시 초기값으로 
지정해야 하며, 이미 선언된 배열에는 문자열을 저장할 
수 없다.
•  문자열 끝에 자동으로 널 문자(‘ \0’)가 삽입되므로, 널 
문자까지 고려하여 배열 크기를 지정해야 한다.
  char a[5] = “love” → love\0
예제  다음의 출력 결과를 확인하시오.
#include	<stdio.h>	
main(	)
{	
		char	a	=	'A';  문자형 변수 a에 문자 ‘A’를 저장한다. 문자
형 변수에는 한 글자만 저장되며, 저장될 때
는 아스키 코드값으로 변경되어 정수로 저
장된다. a가 저장하고 있는 값은 문자로 출
력하면 ‘A’가 출력되지만 숫자로 출력하면 
‘A’에 대한 아스키 코드 65가 출력된다. 
		char	b[9]	=	"SINAGONG";  9개의 요소를 갖는 배열 b
를 선언하고 다음과 같이 
초기화한다. 저장되는 글자
는 8자이지만 문자열의 끝
에 자동으로 저장되는 널 
문자(‘\0’)를 고려하여 크기
를 9로 지정한 것이다.
배열 b SINAGONG\0
b[0]b[1]b[2]b[3]b[4]b[5]b[6]b[7]b[8]
		char	*c	=	"SINAGONG";	 ❶  포인터 변수 c에 “SINAGONG”
이라는 문자열이 저장된 곳의 
주소를 저장한다.
		printf("%c \n",	a);  변수 a의 값을 문자로 출력한다.
		printf("%s \n",	b);  배열 위치를 나타내는 첨자 없이 배열 이
름을 사용하면 배열의 첫 번째 요소의 주
소를 지정하는 것과 같으므로 배열 b의 
첫 번째 요소가 가리키는 곳의 값을 문자
열로 출력한다.20.624.5, 24.2, 23.7, 21.8
배열의 초기화
400704
260핵심배열 형태의 문자열 변수
400705
261핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   80PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   80 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

81
정보처리기사 필기   핵심 요 약		printf("%s \n",	c);  포인터 변수 c가 가리키는 곳의 값을 문
자열로 출력한다.
} 결과 A
SINAGONG
SINAGONG 
코드 해설
메모리
주소
0000
⋮1Byte 1Byte 1Byte 1Byte 1Byte 1Byte 1Byte 1Byte 1Byte
1000 'S''I''N''A''G''O''N''G'\0
⋮1000 1008 1016 1024 1032 1040 1048 1056 1064C1000
9999
위 코드 중 ❶번을 실행할 경우 메모리를 그려보면 다음과 같다.
포인터는 변수의 주소를 말하며, C언어에서는 주소를 제
어할 수 있는 기능을 제공한다.
•  C언어에서 변수의 주소를 저장할 때 사용하는 변수를 
포인터 변수라 한다.
•  포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변
수명 앞에 간접 연산자 *를 붙인다(   int *a;).
•  포인터 변수에 주소를 저장하기 위해 변수의 주소를 알
아낼 때는 변수 앞에 번지 연산자 &를 붙인다(   a = 
&b;).
•  실행문에서 포인터 변수에 간접 연산자 *를 붙이면 해당 
포인터 변수가 가리키는 곳의 값을 말한다(   c = *a;).
•  포인터 변수는 필요에 의해 동적으로 할당되는 메모리 
영역인 힙 영역에 접근하는 동적 변수이다.
메모리
주소
0
a 4 100
8
12
b 50 4예를 들어, a 변수에 100을 저장시키고, a 변수의 주소를 
포인터 변수 b에 기억시켰다면 다음 그림과 같이 표현하
고 말할 수 있다.
• a는 메모리의 4번지에 대한 이름이다.
• a 변수의 주소는 4다.
• a 변수에는 100이 기억되어 있다.
• 4번지에는 100이 기억되어 있다.
• &a는 a 변수의 주소를 말한다. 즉 &a는 4다.
• 포인터 변수 b는 a 변수의 주소를 기억하고 있다.
• 포인터 변수가 가리키는 곳의 값을 말할 때는 *을 붙인다.
•  *b는 b에 저장된 주소가 가리키는 곳에 저장된 값을 말
하므로 100이다.
 예제 1  다음 C언어로 구현된 프로그램의 출력 결과를 확
인하시오. 
main(	)	
{	
	int	a	=	50;	 ❶	정수형 변수 a를 선언하고 50으로 초기화  
한다.
	int	*b;	❷	정수형 변수가 저장된 곳의 주소를 기억할 포
인터 변수 b를 선언한다.
	b	=	&a;	 ❸	정수형 변수 a의 주소를 포인터 변수 b에 기
억시킨다. b에는 a의 주소가 저장된다.
	*b	=	*b+20;	 ❹
	b가 가리키는 곳의 값에 20을 더한다. b가 가
리키는 곳이 a이므로 결국 a의 값도 바뀌는 
것이다.
	printf(“%d,	%d”,	a,	 *b);	❺
	 결과70, 70
	• ❷와 같이 선언할 때 *는 해당 변수가 포인
터 변수라는 것을 의미한다.
• ❹, ❺와 같이 사용할 때 *를 붙이면 그 포
인터 변수가 가리키는 곳의 값을 의미한다.
}
위 코드의 실행 과정에 따라 메모리의 변화를 그려보면 다
음과 같다.
❶, ❷번 수행  : 주기억장치의 빈 공간 어딘가에 a라는 이름
을 붙이고 그 곳에 50을 저장함
메모리
주소
0000
 ⋮
a 1000 50
b ⋮
9999  23.2, 22.4, 21.8
포인터와 포인터 변수
400801
262핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   81PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   81 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

82
정보처리기사 필기   핵심 요 약
 ❸번 수행  : 변수 a의 주소가 b에 기억된다는 것은 b가 변
수 a의 주소를 가리키고 있다는 의미
메모리
주소
0000
 ⋮
a 1000 50
b 1000 ⋮
9999  
 ❹번 수행  : b가 가리키는 곳의 값에 20을 더해 다시 b가 
가리키는 곳에 저장함. 그곳은 변수 a의 주소이므로 변수 
a의 값도 저절로 변경되는 것
메모리
주소
0000
 ⋮
a 1000 70
b 1000 ⋮
9999  
 배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 
요소에 접근할 수 있다. 
•  배열 위치를 나타내는 첨자를 생략하고 배열의 대표명
만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 
것과 같다.
•  배열 요소에 대한 주소를 지정할 때는 일반 변수와 동
일하게 & 연산자를 사용한다.
  int a[5], *b;
 b = a; →  배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주
소를 b에 저장한다.
  b = &a[0]; →  a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장한다.
a[0] a[1] a[2] a[3] a[4] ← 배열 표기 방법
배열 a 첫 번째 두 번째 세 번째 네 번째 다섯 번째
*(a+0) *(a+1) *(a+2) *(a+3) *(a+4) ← 포인터 표기 방법
•  배열의 요소가 포인터인 포인터형 배열을 선언할 수 있다. 예제  다음의 출력 결과를 확인하시오.
main(	)
{	
		int	a[5];  5개의 요소를 갖는 정수형 배열 a를 
선언한다. 선언할 때 사용할 개수를 
선언하고, 사용할 때는 첨자를 0부터 
사용한다.
		int	i;  정수형 변수 i를 선언한다.
		int	*p;	❶
		for	(i	=	0;	i	<	5;	i++)  반복 변수 i가 0에서 시작하여 1씩 
증가하면서 5보다 작은 동안 ❷번
을 반복 수행한다.
						a[i]	=	i	+	10;	 ❷
		p	=	a;	 ❸												
		for	(i	=	0;	i	<	5;	i++)  반복 변수 i가 0에서 시작하여 1씩 
증가하면서 5보다 작은 동안 ❹번
을 반복하여 수행한다.
						printf("%d	",	 *(p+i));	❹결과 10 11 12 13 14 
}
코드의 실행 과정에 따라 메모리의 변화를 그려보면 다음
과 같다.
❶  정수형 변수가 저장된 곳의 주소를 기억할 정수형 포인
터 변수 p를 선언한다.
메모리
주소
0000
⋮
a 1000
a[0] a[1] a[2] a[3] a[4]
p ⋮
9999
❷   배열 a의 i번째에 i+10을 저장한다. i는 0~4까지 변하
므로 배열 a에 저장된 값은 다음과 같다.
메모리
주소
0000
⋮
a 1000 10 11 12 13 14
a[0] a[1] a[2] a[3] a[4]
p ⋮
9999
❸   배열명 a는 배열의 주소이므로 포인터 변수 p에는 배
열 a의 시작 위치가 기억된다. 배열의 이름은 주소이므
로 ‘p = &a’처럼 입력하지 않도록 주의해야 한다. ▶25.5, 25.2, 22.3, 21.5
포인터와 배열 
400802
263핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   82PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   82 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

83
정보처리기사 필기   핵심 요 약메모리
주소
0000
⋮
a 1000 10 11 12 13 14
a[0] a[1] a[2] a[3] a[4]
p 1000 ⋮
9999
❹   p에 저장된 값은 정수형 배열의 시작 주소이다. p의 값
을 1 증가 시킨다는 것은 현재 p가 가리키고 있는 정수
형 자료의 주소에서 다음 정수형 자료의 주소로 가리키
는 주소를 증가시킨다는 것이다. 정수형 자료의 크기
는 4바이트이므로 다음 물리적 메모리의 주소는 4Byte 
증가한 곳을 가리키는 것이다. p에 저장된 배열의 시작 
주소에서 1번지씩, 즉 4Byte씩 증가시키는 것을 그림
으로 표현하면 다음과 같다.
메모리
주소
0000
⋮ 4Byte 4Byte 4Byte 4Byte 4Byte
a 1000 10 11 12 13 14
p + 0 p + 1 p + 2 p + 3 p + 4
p 1000 ⋮ 1000 1004 1008 1012 1016
9999
•  p+0 : 배열의 시작 주소에 0을 더했으므로, 배열의 시
작 주소인 ‘1000’ 번지 그대로이다.
•  (p+0) : ‘1000’ 번지의 값은 10이다. 10을 출력한다.
•  p+1 : ‘1000’에서 한 번지 증가한 주소는 ‘1004’ 번지  
이다.
•  (p+1) : ‘1004’ 번지의 값은 11이다. 11을 출력한다.
•  p+2 : ‘1000’에서 두 번지 증가한 주소는 ‘1008’ 번지  
이다.
•  (p+2) : ‘1008’ 번지의 값은 12이다. 12를 출력한다.
      ⋮▶▶ ▶
▶
input( ) 함수
•  input( ) 함수는 Python의 표준 입력 함수로, 키보드로 
입력받아 변수에 저장하는 함수이다.
• 형식
변수	=	input(출력문자)
	• ‘출력문자 ’는 생략이 가능하며 , ‘변수’
는 사용자가  임의로 지정할 수 있다.
• 값을 입력하고   를 누르면, 입력
한 값이 ‘변수’에 저장된다 .
   a = input('입력하세요.' )  →   화면에 입력하세요. 가 출력
되고 그 뒤에서 커서가 깜빡거리며 입력을 기다린다. 
키보드로 값을 입력하면 변수 a에 저장된다.
print( ) 함수
• 형식1
print(	출력값1,	출력값2,	…,	sep	=	분리문자,	
end	=	종료문자)
	• ‘출력값’에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식이 올 수 있다.
• ‘sep’는 여러 값을 출력할 때 값과 값 사이를 구분하기 위해 출력하는 문
자로, 생략할 경우 기본값은 공백 한 칸(‘ ’)이다.
• ‘end’는 맨 마지막에 표시할 문자로, 생략할 경우 기본값은 줄 나눔이다. 
   print(82, 24, sep = '-', end = ',' )  →  82와 24 사이
에 분리문자 ‘-’가 출력되고, 마지막에 종료문자 ‘,’가 
출력된다.
결과82-24,• 변수의 자료형에 대한 선언이 없다.
•  문장의 끝을 의미하는 세미콜론(;)을 사용할 필요가 없다.
• 변수에 연속하여 값을 저장하는 것이 가능하다. 
  x, y, z = 10, 20, 30
•  if나 for와 같이 코드 블록을 포함하는 명령문을 작성할 
때 코드 블록은 콜론(:)과 여백으로 구분한다.
•  여백은 일반적으로 4칸 또는 한 개의 탭만큼 띄워야하
며, 같은 수준의 코드들은 반드시 동일한 여백을 가져
야 한다.
## 25.2, 24.7, 24.5, 24.2, 22.7, 22.4, 22.3, 21.8, 21.5, 21.3, 20.8 
Python의 데이터  
입·출력 함수
2459962
265핵심Python의 기 본 문법
401101
264핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   83PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   83 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

84
정보처리기사 필기   핵심 요 약
input( ) 함수는 입력되는 값을 무조건 문자열로 저장하므
로, 숫자로 사용하기 위해서는 형을 변환해야 한다.
• 변환할 데이터가 1개일 때
변수	=	int(input(	))  정수로 변환 시
변수	=	float(input(	))  실수로 변환 시
   a = int(input( ))  →  input( )으로 입력받은 값을 정
수로 변환하여 변수 a에 저장한다. 
• 변환할 데이터가 2개 이상일 때
변수1,	변수2,	…	=	map *(int,	input(	).split(	))
 정수로 변환 시
변수1,	변수2,	…	=	map(float,	input(	).split(	))
 실수로 변환 시
   a, b = map(int, input( ).split( ))   
→   i nput( ).split( )으로 입력받은 2개의 값을 정수로 
변환하여 변수 a, b에 저장한다.예 1 방법1 : a = [ 10, ‘mike’, 23.45 ]
 방법2 : a = list([ 10, ‘mike’, 23.45 ])
 a[0] a[1] a[2]
결과 리스트 a 10 mike 23.45
 ※ 두 방법에 대한 결과는 같습니다.
예 2 a[0] = 1  →  a[0]에 1을 저장한다.
 a[0] a[1] a[2]
결과 리스트 a 1 mike 23.45
•  C와 Java에서는 여러 요소들을 하나의 이름으로 처리
할 때 배열을 사용했는데 Python에서는 리스트를 사용
한다.
•  리스트는 필요에 따라 개수를 늘이거나 줄일 수 있기 
때문에 리스트를 선언할 때 크기를 적지 않는다.
•  배열과 달리 하나의 리스트에 정수, 실수, 문자열 등 다
양한 자료형을 섞어서 저장할 수 있다.
• Python에서 리스트의 위치는 0부터 시작한다.
• 형식
리스트명	=	[	값1,	값2,	…	]    리스트명은 사용자가 임의
로 지정하며, 리스트를 의미
하는 대괄호 사이에 저장할 
값들을 쉼표(,)로 구분하여 
입력한다.
리스트명	=	list([	값1,	값2,	…	])•  딕셔너리는 연관된 값을 묶어서 저장하는 용도로 사용
한다.
•  리스트는 저장된 요소에 접근하기 위한 키로 위치에 해
당하는 0, 1, 2 등의 숫자를 사용하지만 딕셔너리는 사
용자가 원하는 값을 키로 지정해 사용한다. 
•  딕셔너리에 접근할 때는 딕셔너리 뒤에 대괄호([  ])를 사
용하며, 대괄호([ ]) 안에 키를 지정한다.
• 형식
딕셔너리명	=	{	키1:값1,	키2:값2,	…	}  
         딕셔너리명은 사용자가 임의로 지정하며, 딕셔 너리를 의
미하는 중괄호 사이에 저장할 값들을 쉼표로 구분하여 입
력한다.   
딕셔너리명	=	dict({	키1:값1,	키2:값2,	…	})
예 1 방법1 : a = {‘이름’:‘홍길동’, ‘나이’:25, ‘주소’:‘서울’}
  방법2 : a = dict({‘이름’:‘홍길동’, ‘나이’:25, ‘주소’:
‘서울’})
 a[‘이름’] a[‘나이’] a[‘주소’]
결과 리스트 a ‘홍길동’ 25 ‘서울’
예 2  a[‘이름’] = ‘이순신’ → 딕셔너리 a의 ‘이름’ 위치에 
‘이순신’을 저장한다.
 a[‘이름’] a[‘나이’] a[‘주소’]
결과 리스트 a ‘이순신’ 25 ‘서울’22.7
## 24.5, 23.5, 22.323.5, 22.3입력 값의 형변환(Casting)
2414031
266핵심
리스트(List) 
2414003
267핵심딕셔너리(Dictionary)
2414004
268핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   84PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   84 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

85
정보처리기사 필기   핵심 요 약• 형식
if	조건:	 	예약어 if와 참 또는 거짓이 결과로 나올 수 있는 
조건을 입력한 후 끝에 콜론(:)을 붙여준다.
			실행할	문장	 	조건이 참일 경우 실행할 문장을 적는다.슬라이스는 문자열이나 리스트와 같은 순차형 객체에서 
일부를 잘라(slicing) 반환하는 기능이다.
• 형식1
객체명[초기위치:최종위치]	‘초기위치’에서 ‘최종위치’-1까
지의 요소들을 가져온다.
객체명[초기위치:최종위치:증가값]
	• ‘초기위치’에서 ‘최종위치’-1까지 ‘증가값’만큼 증가하면서 해당 위치의 요소들을 가져온다.
• ‘증가값’이 음수인 경우 ‘초기위치’에서 ‘최종위치’+1까지 ‘증가값’ 만큼 감소하면서 해당 위치
의 요소들을 가져온다 .
• 슬라이스는 일부 인수를 생략하여 사용할 수 있다.
객체명[:]	또는	객체명[::] 	 객체의 모든 요소를 반환한다.
객체명[초기위치:]
	객체의 ‘초기위치’에서 마지막 위치까지의 
요소들을 반환한다.
객체명[:최종위치]	객체의 0번째 위치에서 ‘최종위치’-1까지의 
요소들을 반환한다.
객체명[::증가값]		 객체의 0번째 위치에서 마지막 위치까지 
‘증가값’만큼 증가하면서 해당 위치의 요소
들을 반환한다.
 a = ['a', 'b', 'c', 'd', 'e']일 때
 a[1:3] → ['b', 'c']
 a[0:5:2] → ['a', 'c', 'e']
 a[3:] → ['d', 'e']
 a[:3] → ['a', 'b', 'c']
 a[::3] → ['a', 'd']예제  a가 10보다 크면 a에서 10을 빼기
a	=	15
if	a	>	10:		 ❶  a가 10보다 크면 ❷번 문장을 실행하고, 아니
면 ❸번 문장으로 이동해서 실행을 계속한다.
				a	=	a	-	10		 ❷ ❶번의 조건식이 참일 경우 실행할 문장이다. 
a는 5가 된다.
print(a)		 ❸  여기서는 ❶번의 조건식이 거짓일 경우 실행
할 문장이 없다. if문을 벗어나면 무조건 ❸번
으로 온다.
      결과 5
• 형식1 : range를 이용하는 방식이다.
for	변수	in	range(최종값):	 	0에서 ‘최종값’-1까지 연속
된 숫자를 순서대로 변수에 
저장하며 ‘실행할 문장’을 반
복 수행한다.
			실행할	문장	 	 	 	반복 수행할 문장을 적는다.
예 1    for  i in range(10): 
sum += i→• i에 0에서 9까지 순서대로 저장하며 실
행할 문장을 반복 수행한다.
• i의 값을 sum에 누적한다. sum에는 0부
터 9까지의 합 45가 저장된다.
예 2    for  i in range(11, 20): 
sum += i→• i에 11에서 19까지 순서대로 저장하며 실
행할 문장을 반복 수행한다.
• i의 값을 sum에 누적한다. sum에는 11부
터 19까지의 합 135가 저장된다.
예 3    for  i in range(-10, 20, 2): 
sum += i→• i에 -10에서 19까지 2씩 증가하
는 숫자를 순서대로 저장하며 
실행할  문장을 반복 수행한다.
• i의 값을 sum에 누적한다. sum
에는 -10, -8, -6, …, 16, 18의 
합 60이 저장된다.
• 형식2 : 리스트(List)를 이용하는 방식이다.
for	변수	in	리스트	 	리스트의 0번째 요소에서 마지막 요
소까지 순서대로 변수에 저장하며 
실행할 문장을 반복 수행한다.
			실행할	문장	 	 	반복 수행할 문장을 적는다.24.2, 20.9, 20.8
## 25.8, 23.7, 22.425.5, 22.6, 21.8슬라이스(Slice)
401106
269핵심
Python - if문
401201
270핵심Python - for문
401202
271핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   85PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   85 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

86
정보처리기사 필기   핵심 요 약
• 형식
while	조건:
	• while은 예약어로, 그대로 입력한다.
• 참이나 거짓을 결과로 갖는 수식을 조건에 입력한다. 
참(1 또는 True)을 직접 입력할 수도 있다. 
	실행할	문장 	조건이 참인 동안 반복 수행할 문장을 적는다.
예제 다음은 1~5까지의 합을 구하는 프로그램을 
Python으로 구현한 것이다.
i,	hap	=	0,	0	 ❶	i와 hap을 0으로 초기화한다 .
while	i	<	5:	 ❷	i가 5보다 작은 동안 ❸, ❹번 문장을 반복하
여 수행한다.예제  다음은 리스트 a에 저장된 요소들의 합과 평균을 
구하는 프로그램을 Python으로 구현한 것이다.
❶	a	=	[	35,	55,	65,	84,	45	]
❷	hap	=	0
❸	for	i	in	a:
❹					hap	+=	i
❺	avg	=	hap	/	len(a)
❻	print(hap,	avg)
코드 해설
❶   리스트 a를 선언하면서 초기값을 지정한다.
a[0] a[1] a[2] a[3] a[4]
리스트 a 35 55 65 84 45
❷ 총점을 저장할 변수 hap을 0으로 초기화한다.
❸ for문의 시작이다. 리스트 a의 요소 수만큼 ❹번을 반복 수행한다.
❹  i의 값을 hap에 누적한다. i는 리스트 a의 각 요소의 값을 차례대로 받는다. 변수의 변
화는 다음과 같다.
    첫 번째 수행  : 리스트 a의 첫 번째 값이 i를 거쳐 hap에 누적된다.
hapi리스트 a
35 35 35 55 65 84 45
두 번째 수행  : 리스트 a의 두 번째 값이 i를 거쳐 hap에 누적된다.
hapi리스트 a
90 55 35 55 65 84 45
     ⋮
이런 방식으로 리스트 a의 요소 수만큼 반복한다.
❺ hap을 리스트 a의 요소 수로 나눈 후 결과를 avg에 저장한다.
     - len(리스트) : 리스트의 요소 수를 구 한다. len(a)는 5다. 
❻ 결과  284 56.8 	i	+=	1	 ❸	 i의 값을 1씩 증가시킨다 .
	hap	+=	i	 ❹	 i의 값을 hap에 누적시킨다.
print(hap)	 ❺	 결과15
• 정의 형식
class	클래스명:	class는 예약어로, 그대로 입력하고 클래스명은 
사용자가 임의로 지정한다.
	실행할	문장
	def	메소드명(self,	인수):
	• def는 메소드를 정의하는 예약어로, 그대로 입력하고, 메소드명은 사
용자가 임의로 지정한다.
• self는 메소드에서 자기 클래스에 속한 변수에 접근할 때 사용하는 명칭
으로, 일반적으로 self를 사용하지만 사용자가 임의로 지정해도 된다.
• ‘인수’는 메소드를 호출하는 곳에서 보낸 값을 저장할 변수로, 사용자
가 임의로 지정한다.
	 	실행할	문장
	 	return	값
	• return은 메소드를 호출한 위치로 값을 돌려주기 위해 사용하는 예약
어로, 그대로 입력한다. return 값이 없는 경우에는 생략할 수 있다.
• ‘값’에는 변수, 객체, 계산식 등이 올 수 있다.
• 객체의 선언 형식
변수명	=	클래스명(	)	변수명은 사용자가 임의로 지정하고, 사전에 정의한 클래스명과 괄호( )를 적는다.
 예제  다음은 두 수를 교환하는 프로그램을 Python으로 
구현한 것이다.
	class	Cls:	Cls 클래스 정의부의 시작점이다. 여기서부터 
❼번까지가 클래스 정의부에 해당한다.
	 	x,	y	=	10,	20	 Cls 클래스의 변수(속성) x와 y를 선언하고, 각
각 10과 20으로 초기화한다.
❹		def	chg(self):
❺	 	 	 	temp	=	self.x
❻	 	 	 	self.x	=	self.y
❼	 	 	 	self.y	=	temp
❶	a	=	Cls(	)
❷	print(a.x,	a.y)
❸	a.chg(	)
❽	print(a.x,	a.y)21.321.5
Python - While문
401203
272핵심Python - 클래스
401204
273핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   86PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   86 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

87
정보처리기사 필기   핵심 요 약코드 해설
❶   Cls 클래스의  객체 a를 생성한다 . 객체 a는 Cls의 속성 x, y와 메소드 chg( )를 갖
는다.
 • a : 사용자 정의 변수다. 사용자가  임의로 지정함
 • Cls( ) : 클래스의  이름이다 . 괄호( )를 붙여 그대로 적음
a.x a.y
a 10 20
❷ a 객체의 속성 x와 y를 출력한다 .
 • 객체와 속성은 .(마침표)로 연결한다 .
결과 10 20
❸ a 객체의 메소드 chg를 호출한다 . ❹번으로 이동한다 .
 • 객체와 메소드는  .(마침표)로 연결한 후 괄호( )를 붙여 적는다.
❹  a 객체의 메소드 chg의 시작점이다 . 별도로 사용되는  인수가 없으므로  괄호( )에
는 self만 적는다.
❺ a 객체의 속성 x의 값을 temp에 저장한다 .
 • self : 메소드 안에서 사용되는  self는 자신이 속한 클래스를  의미함
 • self.x : a.x 와 동일함
  a.x a.y
temp 10 a 10 20
❻ a 객체의 속성 y의 값을 a 객체의 속성 x에 저장한다.
  a.x a.y
temp 10 a 20 20
❼   temp의 값을 a 객체의 속성 y에 저장한다. 메소드 chg가 종료되었으므로 메소드
를 호출한 다음 문장인 ❽번으로 제어를 옮긴다.
  a.x a.y
temp 10 a 20 10
❽ a 객체의 속성 x와 y를 출력한다. 
결과10 20
20 10
언어 특징
C• 1972년 미국 벨 연구소의 데니스 리치에 의해 개발됨
• 시스템 소프트웨어를 개발하기 편리하여 시스템 
프로그래밍 언어로 널리 사용됨
•자료의 주소를 조작할 수 있는 포인터를 제공함 
• 고급 프로그래밍 언어이면서 저급 프로그램 언어
의 특징을 모두 갖춤
•UNIX의 일부가 C 언어로 구현됨
•컴파일러 방식의 언어
• 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램
을 작성할 수 있음
ALGOL• 수치 계산이나 논리 연산을 위한 과학 기술 계산용 
언어
•PASCAL과 C 언어의 모체가 됨
COBOL•사무 처리용 언어
• 영어 문장 형식으로 구성되어 있어 이해와 사용이 
쉬움
•4개의 DIVISION으로 구성되어 있음
FORTRAN•과학 기술 계산용 언어임
• 수학과 공학 분야의 공식이나 수식과 같은 형태로 
프로그래밍 할 수 있음C언어의 사용자 정의 함수와 같이 클래스 없이 메소드만 
단독으로 사용할 수 있다.
예제  다음 프로그램의 실행 결과를 확인하시오.
def	calc(x,	y):		 ❸  메소드 calc의 시작점이다. ❷번에서 calc(a, b)
라고 했으므로 x는 a의 값 3을 받고, y는 b의 
값 12를 받는다.
				x	*=	3		❹	 x = x * 3이므로 x는 9가 된다.
				y	/=	3		 ❺	 y = y / 3 이므로 y는 4가 된다.
				print(x,	y)		 ❻	결과 9 4.0
				return	x		 ❼		x의 값을 반환한다 . x의 값 9를 ❷번의 a에 저
장한 후 제어를 ❽번으로 옮긴다.
a,	b	=	3,	12		 ❶	변수 a와 b에 3과 12를 저장한다 .
a	=	calc(a,	b)		 ❷		a, b 즉 3과 12를 인수로 하여 calc 메소드를  
호출한  결과를  a에 저장한다 . ❸번으로  이동 
한다.
print(a,	b)		 ❽	 결과9 4.0
9 12
 23.7, 23.2, 21.8
절차적 프로그래밍 언어의  
종류
401403
275핵심클래스 없는 메소드의 사용 
401232
274핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   87PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   87 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

107
정보처리기사 필기   핵심 요 약흐름 제어란 네트워크 내의 원활한 흐름을 위해 송·수신 
측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능
이다.
정지-대기
(Stop-and-Wait)• 수신 측의 확인 신호(ACK)를 받은 후에 다음 
패킷을 전송하는 방식
•한 번에 하나의 패킷만을 전송할 수 있음
슬라이딩 윈도우
(Sliding Window)• 확인 신호, 즉 수신 통지를 이용하여 송신 
데이터의 양을 조절하는 방식
• 수신 측의 확인 신호를 받지 않더라도 미리 
정해진 패킷의 수만큼 연속적으로 전송하는 
방식으로, 한 번에 여러 개의 패킷을 전송할 
수 있어 전송 효율이 좋음
• 송신 측은 수신 측으로부터 확인 신호(ACK) 
없이도 보낼 수 있는 패킷의 최대치를 미리 
약속받는데, 이 패킷의 최대치가 윈도우 크
기(Window Size)를 의미함
• 윈도우 크기(Window Size)는 상황에 따라 변
한다. 즉, 수신 측으로부터 이전에 송신한 패
킷에 대한 긍정 수신 응답(ACK)이 전달된 경
우 윈도우 크기는 증가하고, 수신 측으로부터 
이전에 송신한 패킷에 대한 부정 수신 응답
(NAK)이 전달된 경우 윈도우 크기는 감소함
매시업(Mashup)웹에서 제공하는 정보 및 서비스를 이용하여 
새로운 소프트웨어나 서비스, 데이터베이스 등
을 만드는 기술이다. 즉 다수의 정보원이 제공
하는 콘텐츠를 조합하여 하나의 서비스로 제공
하는 웹 사이트 또는 애플리케이션을 말함
서비스 지향 
아키텍처
(SOA; Service 
Oriented 
Architecture)• 기업의 소프트웨어 인프라인 정보시스템을 
공유와 재사용이 가능한 서비스 단위나 컴포
넌트 중심으로 구축하는 정보기술 아키텍처
• SOA 기반 애플리케이션 구성 계층 : 표
현(Presentation) 계층, 업무 프로세스
(Biz-Process) 계층, 서비스 중간(Service 
Intermediary) 계층, 애플리케이션(Application) 
계층, 데이터 저장(Persistency) 계층
디지털 트윈
(Digital Twin)• 현실속의 사물을 소프트웨어로 가상화한 모
델로, 자동차, 항공, 에너지, 국방, 헬스케어 
등 여러 분야에서 주목 받음
• 실제 물리적인 자산을 소프트웨어로 가상화
함으로써 실제 자산의 특성에 대한 정확한 
정보를 얻을 수 있고, 자산 최적화, 돌발사고 
최소화, 생산성 증가 등 설계부터 제조, 서비
스에 이르는 모든 과정의 효율성을 향상시킬 
수 있음텐서플로
(TensorFlow)• 구글의 구글 브레인(Google Brain) 팀이 만든, 
다양한 작업에 대해 데이터 흐름 프로그래밍
을 위한 오픈소스 소프트웨어 라이브러리
• C++언어로 제작되었고, 구글 검색, 음성 인
식, 번역 등의 구글 서비스 전반에서 다양하
게 사용되고 있음
도커(Docker)• 컨테이너 기술을 자동화하여 쉽게 사용할 수 
있게 하는 오픈소스 프로젝트
• 소프트웨어 컨테이너 안에 응용 프로그램들
을 배치시키는 일을 자동화해주는 역할을 수
행함
스크래피(Scrapy)Python 기반의 웹 크롤링 프레임워크로, 코드 
재사용성을 높이는 데 도움이 되며, 대규모의 
크롤링 프로젝트에 적합함
증발품
(Vaporware)판매 계획 또는 배포 계획은 발표되었으나 실
제로 고객에게 판매되거나 배포되지 않고 있는 
소프트웨어
서비스형 블록
체인(BaaS; 
Blockchain as 
a Service)• 블록체인(Blockchain) 앱의 개발 환경을 클라우
드 기반으로 제공하는 서비스
• 블록체인 네트워크에 노드의 추가 및 제거가 용
이하고, 블록체인 플랫폼마다 다른 브록체인 기
술을 보다 편리하게 사용할 수 있게 함
OWASP(the 
Open Web 
Application 
Security 
Project)• 웹 정보 노출이나 악성 코드, 스크립트, 보안이 
취약한 부분을 연구하는 비영리 단체
• 보안 취약점 중 보안에 미치는 영향이 큰 것을 
기준으로 선정한 10대 웹 애플리케이션 취약점
을 3~4년에 한 번씩 발표하고 있음
TCP 래퍼(TCP 
Wrapper)• 외부 컴퓨터의 접속 인가 여부를 점검하여 접속
을 허용 및 거부하는 보안용 도구
• 네트워크에 접속하면 로그인한 다른 컴퓨터 사
용자의 ID 및 로그를 조회하여 악용이 가능한 데, 
이것을 방지하기 위한 방화벽 역할을 수행함
허니팟
(Honeypot)• 비정상적인 접근을 탐지하기 위해 설치해 둔 시
스템
• 침입자를 속여 실제 공격을 당하는 것처럼 보여
줌으로써 추적 및 공격기법에 대한 정보를 수집
함
DPI(Deep 
Packet 
Inspection)OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 
콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하
고, 트래픽을 조정하기 위한 패킷 분석 기술20.9
## 25.8, 25.5, 24.5, 24.2, 23.7, 23.2, 22.3, 21.8, 20.9, 20.825.8, 25.2, 24.7, 24.5, 24.2, 23.7, 23.5, 23.2, 22.7, 22.4, 22.3, 21.8, 21.3흐름 제어(Flow Control)
2418004
345핵심
SW 관련 용어
2418101
346핵심보안 관련 용어
2418201
347핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   107PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   107 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

109
정보처리기사 필기   핵심 요 약그림자 페이지 
대체 기법
(Shadow 
Paging)• 갱신 이전의 데이터베이스를 일정 크기의 페이
지 단위로 구성하여 각 페이지마다 복사본인 그
림자 페이지로 별도 보관해 놓고, 실제 페이지
를 대상으로 트랜잭션에 의한 갱신 작업을 하다
가 장애가 발생하여 트랜잭션 작업을 Rollback
시킬 때, 갱신된 이후의 실제 페이지 부분에 그
림자 페이지를 대체하여 회복시키는 기법
•로그, Undo 및 Redo 알고리즘이 필요 없음
검사점 기법
(Check Point)트랜잭션 실행 중 특정 단계에서 재실행할 수 있
도록 갱신 내용이나 시스템에 대한 상황 등에 관
한 정보와 함께 검사점을 로그에 보관해 두고, 장
애 발생 시 트랜잭션 전체를 철회하지 않고 검사
점부터 회복 작업을 하여 회복시간을 절약하도록 
하는 기법타조
(Tajo)오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 
하둡(Apache Hadoop) 기반의 분산 데이터 웨
어하우스 프로젝트로, 우리나라가 주도하여 개
발하고 있음
데이터 마이닝
(Data Mining)• 데이터 웨어하우스에 저장된 데이터 집합에
서 사용자의 요구에 따라 유용하고 가능성 
있는 정보를 발견하기 위한 기법
• 대량의 데이터를 분석하여 데이터 속에 내재
되어 있는 변수 사이의 상호관계를 규명하여 
패턴화함으로써 효율적인 데이터 추출이 가
능함
OLAP(Online 
Analytical 
Processing)• 다차원으로 이루어진 데이터로부터 통계적
인 요약 정보를 분석하여 의사결정에 활용하
는 방식을 말함
• OLAP 연산 : Roll-up, Drill-down, Drill-
through, Drill-across, Pivoting, Slicing, Dicing
•  회복은 트랜잭션들을 수행하는 도중 장애가 발생하여 
데이터베이스가 손상되었을 때 손상되기 이전의 정상 
상태로 복구하는 작업이다.
• 회복 기법
연기 갱신 기법
(Deferred 
Update)• 트랜잭션이 성공적으로 완료될 때까지 데이터
베이스에 대한 실질적인 갱신을 연기하는 방법
• 트랜잭션이 수행되는 동안 갱신된 내용은 일단 
Log에 보관됨
• 트랜잭션의 부분 완료(성공적인 완료 직전) 시점
에 Log에 보관한 갱신 내용을 실제 데이터베이
스에 기록함
• 트랜잭션이 부분 완료되기 전에 장애가 발생하
여 트랜잭션이 Rollback되면 트랜잭션이 실제 
데이터베이스에 영향을 미치지 않았기 때문에 
어떠한 갱신 내용도 취소(Undo)시킬 필요 없이 
무시하면 됨
•Redo 작업만 가능함
즉각 갱신 기법
(Immediate 
Update)• 트랜잭션이 데이터를 갱신하면 트랜잭션이 부
분 완료되기 전이라도 즉시 실제 데이터베이스
에 반영하는 방법
• 장애가 발생하여 회복 작업할 경우를 대비하여 
갱신된 내용들은 Log에 보관시킴
• 회복 작업을 할 경우에는 Redo와 Undo 모두 사
용 가능함병행제어란 다중 프로그램의 이점을 활용하여 동시에 여
러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트
랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트
랜잭션 간의 상호 작용을 제어하는 것이다.
• 병행제어 기법의 종류
로킹
(Locking)• 주요 데이터의 액세스를 상호 배타적으로 하는 것
• 트랜잭션들이 어떤 로킹 단위를 액세스하기 전
에 Lock(잠금)을 요청해서 Lock이 허락되어야만 
그 로킹 단위를 액세스할 수 있도록 하는 기법
타임 스탬프 
순서
(Time Stamp 
Ordering)• 직렬성 순서를 결정하기 위해 트랜잭션 간의 처
리 순서를 미리 선택하는 기법들 중에서 가장 
보편적인 방법
• 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터
에 대해 트랜잭션이 실행을 시작하기 전에 시간
표(Time Stamp)를 부여하여 부여된 시간에 따라 
트랜잭션 작업을 수행하는 기법
•교착상태가 발생하지 않음
최적 병행수행
(검증 기법, 확
인 기법, 낙관
적 기법)병행수행하고자 하는 대부분의 트랜잭션이 판독 
전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 
충돌률이 매우 낮아서 병행제어 기법을 사용하지 
않고 실행되어도 이 중의 많은 트랜잭션은 시스템
의 상태를 일관성 있게 유지한다는 점을 이용한 
기법
다중 버전 기법• 타임 스탬프의 개념을 이용하는 기법으로, 다중 
버전 타임 스탬프 기법이라고도 함
• 타임 스탬프 기법은 트랜잭션 및 데이터들이 이
용될 때의 시간을 시간표로 관리하지만, 다중 
버전 기법은 갱신될 때마다의 버전을 부여하여 
관리함25.5, 25.2, 24.7, 24.5, 24.2, 23.5, 23.2, 21.8, 21.5, 21,3, 20.9, 20.8, 20.6
## 25.2, 24.7, 23.5, 21.3, 20.8병행제어  
(Concurrency Control)
2459947
353핵심
회복(Recovery)
2459946
352핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   109PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   109 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34

113
정보처리기사 필기   핵심 요 약공개키 암호화 기법은 데이터를 암호화할 때 사용하는 공
개키(Public Key)는 데이터베이스 사용자에게 공개하고, 
복호화할 때의 비밀키(Secret Key)는 관리자가 비밀리에 
관리한다.
•  공개키 암호화 기법에서 암호화 대상이 n개일 때 사용
되는 키의 개수는 2n이다.
•  공개키 암호화 기법은 비대칭 암호 기법이라고도 하며, 
대표적으로는 RSA(Rivest Shamir Adleman) 기법이 
있다.
개인키 암호화 방식과 공개키 암호화 방식에서 사용되는 
주요 암호화 알고리즘에는 SEED, ARIA 등이 있다. 
SEED• 1999년 한국인터넷진흥원(KISA)에서 개발한 
블록 암호화 알고리즘
• 블록 크기는 128비트이며, 키 길이에 따라 128, 
256으로 분류됨
ARIA
(Academy, 
Research 
Institute, 
Agency)• 2004년 국가정보원과 산학연협회가 개발한 
블록 암호화 알고리즘
• ARIA는 학계(Academy), 연구기관(Research 
Institute), 정부(Agency)의 영문 앞 글자로 구성
됨
• 블록 크기는 128비트이며, 키 길이에 따라 128, 
192, 256으로 분류됨
DES(Data 
Encryption 
Standard)• 1975년 미국 NBS에서 발표한 개인키 암호화 
알고리즘
• DES를 3번 적용하여 보안을 더욱 강화한 
3DES (Triple DES)도 있음
•블록 크기는 64비트이며, 키 길이는 56비트
AES
(Advanced 
Encryption 
Standard)• 2001년 미국 표준 기술 연구소(NIST)에서 발표
한 개인키 암호화 알고리즘
• DES의 한계를 느낀 NIST에서 공모한 후 발표하
였다.
• 블록 크기는 128비트이며, 키 길이에 따라 128, 
192, 256으로 분류됨RSA
(Rivest Shamir 
Adleman) • 1978년 MIT의 라이베스트(Rivest), 샤미르
(Shamir), 애들먼(Adelman)에 의해 제안된 공
개키 암호화 알고리즘
• 큰 숫자를 소인수분해 하기 어렵다는 것에 기
반하여 만들어짐
• 공개키와 비밀키를 사용하는데, 여기서 키란 
메시지를 열고 잠그는 상수(Constant)를 의미
함 
ECC(Elliptic 
Curve 
Cryptography)•1985년 RSA 암호 방식의 대안으로 제안됨
• 이산대수 문제를 타원곡선으로 옮겨 기밀성과 
효율성을 높인 암호화 알고리즘임
Rabin•1979년 미하엘 라빈이 제안하였음
• 소인수분해의 어려움에 안전성의 근거를 둔 암
호화 알고리즘임
해시는 임의의 길이의 입력 데이터나 메시지를 고정된 길
이의 값이나 키로 변환하는 것을 의미한다.
•  해시 알고리즘을 해시 함수라고 부르며, 해시 함수로 
변환된 값이나 키를 해시값 또는 해시키라고 부른다.
•  데이터의 암호화, 무결성 검증을 위해 사용될 뿐만 아
니라 정보보호의 다양한 분야에서 활용된다.
•  해시 함수의 종류에는 SHA 시리즈, MD5, N-NASH, 
SNEFRU 등이 있다.
SHA 
시리즈• 1993년 미국 국가안보국(NSA)이 처음 설계했으며, 미
국 국립표준기술연구소(NIST)에 의해 발표됨
• 초기 개발된 SHA-0 이후 SHA-1이 발표되었고, 다시 
SHA-2라고 불리는 SHA-224, SHA-256, SHA-384, 
SHA-512가 발표됨
MD5• 1991년 R.Rivest가 MD4를 대체하기 위해 고안한 암호
화 해시 함수
•블록 크기는 512비트이며, 키 길이는 128비트
N-NASH• 1989년 일본의 전신전화주식회사(NTT)에서 발표한 
암호화 해시 함수
•블록 크기와 키 길이가 모두 128비트
SNEFRU•1990년 R.C.Merkle가 발표한 해시 함수
• 32비트 프로세서에서 구현을 용이하게 할 목적으로 
개발됨
• 블록 크기는 512비트이며, 키 길이에 따라 128과 256
으로 분류됨25.5, 23.2, 22.4, 21.3, 20.9
## 25.8, 25.5, 25.2, 24.7, 24.5, 24.2, 23.7, 23.5, 22.7, 22.3, 21.8, 20.8, 20.625.2, 24.5, 23.7, 23.2, 22.7, 21.5, 21.3공개키 암호화(Public Key 
Encryption) 기법
2420003
363핵심
양방향 알고리즘 종류
2420032
364핵심해시(Hash)
2420004
365핵심
PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   113PDF_2026기출문제집필기_핵심 정보처리기사(001~116)_ej2.indd   113 2025. 10. 30.   오후 4:342025. 10. 30.   오후 4:34